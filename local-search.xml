<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>scanf() 中的跳过与字符匹配</title>
    <link href="/2023/04/05/scanf-%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%BF%87%E4%B8%8E%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
    <url>/2023/04/05/scanf-%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%BF%87%E4%B8%8E%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="scanf-的-“转换指令”-的组成"><a href="#scanf-的-“转换指令”-的组成" class="headerlink" title="scanf() 的 “转换指令” 的组成"></a>scanf() 的 “转换指令” 的组成</h1><blockquote><p>这一部分主要是标准的翻译与诠释，而且和文字标题中的两个关键字关系不大，只想知道怎么用的同学可以忽略（）</p></blockquote><p><code>scanf()</code> 的第一个参数由零个或多个转换指令（directives）组成，而每个指令又为一个或多个空白字符、既不是 <code>%</code> 也不是空白字符的原始字符串，或者一个 <strong>转换指示符（conversion specification）</strong>。</p><blockquote><p>上面这个句子晦涩难懂，也许不是人话，但是下面的就好理解了 ~</p></blockquote><p>每一个转换指示符 <strong>由 <code>%</code> 开头</strong>，并随其后 <strong>依次</strong> 出现：</p><ul><li><p>一个 <strong>可选的</strong>、<strong>抑制赋值（assignment-suppressing）</strong> 的字符：<code>*</code>。</p></li><li><p>一个 <strong>可选的</strong>、以十进制正整数形式呈现的数字，用以指示最大宽度（以字符的形式）。</p></li><li><p>一个 <strong>可选的</strong>、用以指示待接收对象 “尺寸” 的 <strong>长度修饰符（length modifier）</strong>。</p></li><li><p>一个 <strong>类型指示符（conversion specifier）</strong>。</p></li></ul><p>比如：</p><ul><li><p><code>%d</code>，<code>d</code> 为 “类型指示符”，表示读取的是整数。</p></li><li><p><code>%lld</code>，<code>ll</code> 为 “长度修饰符”，表示读取整数的长度。</p></li><li><p><code>%20s</code>，<code>20</code> 表示最大的域宽度，不会超过 <code>20</code> 个字符（实验结果表明，这个 <code>20</code> 不包含 <code>\0</code>， 实验参见 “<a href="#%E5%AE%9E%E9%AA%8C%E8%AF%81%E6%98%8E%E6%9C%80%E5%A4%A7%E5%9F%9F%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8C%85%E5%90%AB-0">附录</a>”）。</p></li></ul><h1 id="让-scanf-读取变量但将其忽略"><a href="#让-scanf-读取变量但将其忽略" class="headerlink" title="让 scanf 读取变量但将其忽略"></a>让 scanf 读取变量但将其忽略</h1><p>正如标准中所说，可以用 <code>*</code> 来让将读取到的东西忽略：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%*d%d&quot;</span>, &amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<br></code></pre></td></tr></table></figure><p>输给它两个整数，会忽略第一个，并将第二个整数读取：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">In [1]: 123 321<br>Out[1]: 321<br></code></pre></td></tr></table></figure><p>对字符串当然适用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s[<span class="hljs-number">20</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%*8s%s&quot;</span>, s);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, s);<br></code></pre></td></tr></table></figure><p>这时候会忽略前 8 个字符（假定输入没有空白字符），从第九个开始读取：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">In [2]: 1234567890<br>Out[2]: 90<br></code></pre></td></tr></table></figure><p>如上，构造连续内存，使 <code>c</code> 紧跟 <code>s</code> 之后，以消除被添加的 <code>\0</code>。当输入为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">12345678<br></code></pre></td></tr></table></figure><p>时，输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">12345678*<br></code></pre></td></tr></table></figure><p>如果不指定位宽 <code>8</code>，那么会像正常那样读到空白符，并一股脑儿丢掉。</p><h1 id="scanset-与指定字符匹配"><a href="#scanset-与指定字符匹配" class="headerlink" title="scanset 与指定字符匹配"></a>scanset 与指定字符匹配</h1><h2 id="匹配指定字符"><a href="#匹配指定字符" class="headerlink" title="匹配指定字符"></a>匹配指定字符</h2><p>标准中提到，类型指示符除了通常的 <code>d,c,s</code> 等等，还有一个 <code>[</code>，用来读取字符串，但是只读取列表中指定的字符。看一个简单的例子，只读取 <code>abcd</code> 四个字母：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s[<span class="hljs-number">1024</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%[abcd]&quot;</span>, s);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, s);<br></code></pre></td></tr></table></figure><p>当遇到其他字符（包括空白符）会 <strong>结束匹配</strong>，并将剩下的 <strong>留在缓冲区</strong>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">In [3]: acccbdb3210<br>Out[3]: acccbdb<br>In [4]: acccbdb 3210<br>Out[4]: acccbdb<br></code></pre></td></tr></table></figure><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><h1 id="术语表-x2F-Glossary"><a href="#术语表-x2F-Glossary" class="headerlink" title="术语表 &#x2F; Glossary"></a>术语表 &#x2F; Glossary</h1><table><thead><tr><th align="center">标准中的原文</th><th align="center">此文中的译文</th></tr></thead><tbody><tr><td align="center">directives</td><td align="center">转换指令</td></tr><tr><td align="center">conversion specification</td><td align="center">转换指示符</td></tr><tr><td align="center">assignment-suppressing</td><td align="center">抑制赋值</td></tr><tr><td align="center">conversion specifier</td><td align="center">类型指示符</td></tr><tr><td align="center">field width (in characters)</td><td align="center">域宽度（以字符的形式）</td></tr><tr><td align="center">length modifier</td><td align="center">长度修饰符</td></tr></tbody></table><h1 id="附录-x2F-Appendix"><a href="#附录-x2F-Appendix" class="headerlink" title="附录 &#x2F; Appendix"></a>附录 &#x2F; Appendix</h1><h2 id="实验证明最大域宽度不包含-0"><a href="#实验证明最大域宽度不包含-0" class="headerlink" title="实验证明最大域宽度不包含 \0"></a>实验证明最大域宽度不包含 <code>\0</code></h2><p><a href="#scanf-%E7%9A%84-%E2%80%9C%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4%E2%80%9D-%E7%9A%84%E7%BB%84%E6%88%90">跳转回去</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">char</span> s[<span class="hljs-number">8</span>], c;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%8s&quot;</span>, s);<br>    c = <span class="hljs-string">&#x27;*&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考文献-x2F-Reference"><a href="#参考文献-x2F-Reference" class="headerlink" title="参考文献 &#x2F; Reference"></a>参考文献 &#x2F; Reference</h1><p>[1] ISO&#x2F;IEC 9899:TC3</p>]]></content>
    
    
    <categories>
      
      <category>C 语言教程</category>
      
      <category>语法讲解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 多线程编程学习札记</title>
    <link href="/2023/04/01/CPP-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    <url>/2023/04/01/CPP-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>在 C++11 及之后的标准中，引入了 <code>&lt;thread&gt;</code> 头文件，在语言层面上引入了多线程的操作。因为是学习笔记，故基础概念不涉及。</p><span id="more"></span><h1 id="创建子线程"><a href="#创建子线程" class="headerlink" title="创建子线程"></a>创建子线程</h1><h2 id="通过函数创建子线程"><a href="#通过函数创建子线程" class="headerlink" title="通过函数创建子线程"></a>通过函数创建子线程</h2><p>通过 <code>::std::thread</code> 的构造方法，可以从函数创建子线程。其构造函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">thread</span>(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args);<br></code></pre></td></tr></table></figure><p>参数一为可调用的函数，后续变长参数为参数。下面的例子创建了一个子线程，其调用的函数无参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_void</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;@ child thread #0: %3d\n&quot;</span>, n);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">200000</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    ::<span class="hljs-function">std::thread <span class="hljs-title">th1</span><span class="hljs-params">(print_void)</span></span>;<br><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;@ main  thread #0: %3d\n&quot;</span>, n);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">100000</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能的运行结果如下，同时注意到，程序被 <strong>Aborted</strong> 了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">@ main  thread #0:   9<br>@ child thread #0:   3<br>@ main  thread #0:   8<br>@ child thread #0:   2<br>@ main  thread #0:   7<br>@ main  thread #0:   6<br>@ child thread #0:   1<br>@ main  thread #0:   5<br>@ main  thread #0:   4<br>@ child thread #0:   0<br>@ main  thread #0:   3<br>@ main  thread #0:   2<br>@ main  thread #0:   1<br>@ main  thread #0:   0<br>terminate called without an active exception<br>Aborted (core dumped)<br></code></pre></td></tr></table></figure><p>这是因为，在一个 <code>thread</code> 对象<strong>被析构前</strong>， **必须被显式地指派为 <code>join</code> 或者 <code>detach</code>**，否则析构函数会调用 <code>::std::terminate()</code> 终止程序。</p><h2 id="join-与-detach"><a href="#join-与-detach" class="headerlink" title="join 与 detach"></a>join 与 detach</h2><p>通过调用 <code>th1.join</code>，主线程会被 <strong>阻塞</strong>，直到子线程运行完毕后，才会进行主线程的后续操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_void</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;@ child thread #0: %3d\n&quot;</span>, n);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50000</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    ::<span class="hljs-function">std::thread <span class="hljs-title">th1</span><span class="hljs-params">(print_void)</span></span>;<br><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;@ main  thread #0: %3d\n&quot;</span>, n);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">100000</span>);<br>    &#125;<br><br>    th1.<span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main thread end\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，按道理是主线程会更快地结束，但是主线程会被 “卡在” <code>th1.join()</code> 处，等待子线程结束。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">@ main  thread #0:   3<br>@ child thread #0:   9<br>@ child thread #0:   8<br>@ main  thread #0:   2<br>@ child thread #0:   7<br>@ child thread #0:   6<br>@ main  thread #0:   1<br>@ child thread #0:   5<br>@ child thread #0:   4<br>@ main  thread #0:   0<br>@ child thread #0:   3<br>@ child thread #0:   2<br>@ child thread #0:   1<br>@ child thread #0:   0<br>main thread end<br></code></pre></td></tr></table></figure><p>通过调用 <code>th1.detach()</code>，可以让子线程与主线程分离，主线程不再具有子线程的管理权。但是当主线程结束后，主进程会结束，导致子线程被终结（<strong>猜测</strong>）。需要注意的是，调用 <code>detach()</code> 会使得该线程 **不能再被 <code>join</code>**。并且，通常 <code>detach</code> 一般在线程被创建时调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_void</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;@ child thread #0: %3d\n&quot;</span>, n);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">50000</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    ::<span class="hljs-function">std::thread <span class="hljs-title">th1</span><span class="hljs-params">(print_void)</span></span>;<br>    th1.<span class="hljs-built_in">detach</span>();<br><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;@ main  thread #0: %3d\n&quot;</span>, n);<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">100000</span>);<br>    &#125;<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main thread end\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，可以注意到，子线程后续的信息没有被打印出来，因为这个时候主线程已经结束：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">@ main  thread #0:   3<br>@ child thread #0:   9<br>@ child thread #0:   8<br>@ main  thread #0:   2<br>@ child thread #0:   7<br>@ child thread #0:   6<br>@ main  thread #0:   1<br>@ child thread #0:   5<br>@ child thread #0:   4<br>@ main  thread #0:   0<br>@ child thread #0:   3<br>@ child thread #0:   2<br>main thread end<br></code></pre></td></tr></table></figure><p>通过 <code>th1.joinable()</code> 可以获知，该子线程是否已经被指定了退出方式。</p><h1 id="互斥锁与原子锁"><a href="#互斥锁与原子锁" class="headerlink" title="互斥锁与原子锁"></a>互斥锁与原子锁</h1><p>当多个线程需要操控同一个变量时，需要给它 “上锁”，不然会出问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">child_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; ++i) &#123;<br>        ++n;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    ::<span class="hljs-function">std::thread <span class="hljs-title">th1</span><span class="hljs-params">(child_thread, <span class="hljs-number">1000000</span>)</span></span>;<br>    ::<span class="hljs-function">std::thread <span class="hljs-title">th2</span><span class="hljs-params">(child_thread, <span class="hljs-number">1000000</span>)</span></span>;<br>    th1.<span class="hljs-built_in">join</span>();<br>    th2.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述程序输出的结果不可预知，<code>n</code> 的值没有被正确求出。</p><p><img src="/img/mt-wrong.jpg" alt="某两次的运行结果"></p><h2 id="互斥锁：mutex"><a href="#互斥锁：mutex" class="headerlink" title="互斥锁：mutex"></a>互斥锁：mutex</h2><p>需要包含头文件 <code>&lt;mutex&gt;</code>，使用 <code>::std::mutex mtx;</code> 可以创建一个互斥锁。</p><p><code>mtx.lock()</code> 可以将其上锁，如果已经被其他线程上锁，则会被阻塞，直到锁被释放为止。</p><p><code>mtx.unlock()</code> 可以释放锁。</p><p><code>mtx.try_lock()</code> 可以尝试上锁，若该锁已经被其他线程锁上，则会返回 <code>false</code>，否则会将其上锁，并且返回 <code>true</code>。</p><p>将上述例子如是修改，便可以正确得到 <code>n</code> 的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">::std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">child_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; ++i) &#123;<br>        mtx.<span class="hljs-built_in">lock</span>();<br>        ++n;<br>        mtx.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子锁：atomic"><a href="#原子锁：atomic" class="headerlink" title="原子锁：atomic"></a>原子锁：atomic</h2><p>通过 <code>atomic</code> 头文件中的 <code>::std::atomic</code> 模板类可以声明若干 “原子变量”，对这些变量的操作自带锁，并且相较于 <code>mutex</code> 的反复上锁、解锁，具有更高的效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>::std::atomic&lt;<span class="hljs-type">int</span>&gt; n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">child_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; ++i) &#123;<br>        ++n;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    ::<span class="hljs-function">std::thread <span class="hljs-title">th1</span><span class="hljs-params">(child_thread, <span class="hljs-number">1000000</span>)</span></span>;<br>    ::<span class="hljs-function">std::thread <span class="hljs-title">th2</span><span class="hljs-params">(child_thread, <span class="hljs-number">1000000</span>)</span></span>;<br>    th1.<span class="hljs-built_in">join</span>();<br>    th2.<span class="hljs-built_in">join</span>();<br>    ::std::cout &lt;&lt; n &lt;&lt; ::std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异步调用：async"><a href="#异步调用：async" class="headerlink" title="异步调用：async"></a>异步调用：async</h1><!-- https://blog.csdn.net/sjc_0910/article/details/118861539 -->]]></content>
    
    
    <categories>
      
      <category>C++ 教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
      <tag>代码笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 的迭代库——让遍历算法更加优雅</title>
    <link href="/2023/03/30/Python-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%BA%93%E2%80%94%E2%80%94%E8%AE%A9%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E6%9B%B4%E5%8A%A0%E4%BC%98%E9%9B%85/"/>
    <url>/2023/03/30/Python-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%BA%93%E2%80%94%E2%80%94%E8%AE%A9%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E6%9B%B4%E5%8A%A0%E4%BC%98%E9%9B%85/</url>
    
    <content type="html"><![CDATA[<p>【学学 Python 吧，感受随心所欲的优雅】你是否被层层叠叠的循环搞得焦头烂额？你是否想用全排列但是不想写递归？让 <code>itertools</code> 库帮你排忧纾难！</p><span id="more"></span><h1 id="索引-x2F-Index"><a href="#索引-x2F-Index" class="headerlink" title="索引 &#x2F; Index"></a>索引 &#x2F; Index</h1><p>索引只列出了用得比较多的 <strong>部分函数</strong>，其余使用较少或者难以总结的，在正文中均有列出，可以参看 <strong>右方目录</strong>。</p><table><thead><tr><th align="center">使用频次</th><th align="center">用处</th><th align="center">跳转</th><th align="center">例题</th></tr></thead><tbody><tr><td align="center"></td><td align="center">数数字，从 1 到 $\infty$</td><td align="center"><a href="#%E6%95%B0%E6%95%B0%EF%BC%9Acount-start-step">count</a></td><td align="center"></td></tr><tr><td align="center">⭐</td><td align="center">重复，循环遍历列表</td><td align="center"><a href="#%E5%BE%AA%E7%8E%AF%EF%BC%9Acycle-p">cycle</a></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">重复，管它什么玩意儿，就是重复</td><td align="center"><a href="#%E9%87%8D%E5%A4%8D%EF%BC%9Arepeat-elem-n">repeat</a></td><td align="center"></td></tr><tr><td align="center">⭐⭐⭐</td><td align="center">排列！全排列！$A_m^n$</td><td align="center"><a href="#%E6%8E%92%E5%88%97%EF%BC%9Apermutations-p-r">permutations</a></td><td align="center"><a href="#%E6%89%93%E5%8D%B0%E5%85%A8%E6%8E%92%E5%88%97">打印全排列</a></td></tr><tr><td align="center">⭐⭐⭐</td><td align="center">组合！就是组合！$C_m^n$</td><td align="center"><a href="#%E7%BB%84%E5%90%88%EF%BC%9Acombinations-p-r">combinations</a></td><td align="center"><a href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%92%8C">最接近的和</a></td></tr><tr><td align="center">⭐</td><td align="center">组合，但是可以重复</td><td align="center"><a href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%84%E5%90%88%EF%BC%9Acombinations-with-replacement-p-r">comb._with_rep.</a></td><td align="center"></td></tr><tr><td align="center">⭐⭐</td><td align="center">压缩多层循环，笛卡尔积</td><td align="center"><a href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%EF%BC%9Aproduct-p-q-%E2%80%A6-repeat-x3D-1">product</a></td><td align="center"><a href="#%E7%AD%89%E5%B7%AE%E6%97%B6%E9%97%B4">等差时间</a></td></tr><tr><td align="center">⭐⭐</td><td align="center">挑选，使用给定函数判断</td><td align="center"><a href="#%E6%8C%89%E9%9C%80%E9%80%89%E6%8B%A9%EF%BC%9Afilterfalse-predicate-iterable">filterfalse</a></td><td align="center"></td></tr><tr><td align="center">⭐</td><td align="center">挑选，使用真值列表</td><td align="center"><a href="#%E6%8C%91%E9%80%89%E5%8E%8B%E7%BC%A9%EF%BC%9Acompress-data-selectors">compress</a></td><td align="center"></td></tr><tr><td align="center">⭐</td><td align="center">累加，从头开始累加</td><td align="center"><a href="#%E7%B4%AF%E5%8A%A0%EF%BC%9Aaccumulate-p-func">accumulate</a></td><td align="center"><a href="#%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E5%92%8C">计算阶乘和</a></td></tr><tr><td align="center"></td><td align="center">邻接配对，和邻居绑一起</td><td align="center"><a href="#%E9%82%BB%E6%8E%A5%E9%85%8D%E5%AF%B9%EF%BC%9Apairwise-iterable-%E3%80%90Python-geqslant-3-10-%E3%80%91">pairwise</a></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">邻接分组，连续的同组的</td><td align="center"><a href="#%E9%82%BB%E6%8E%A5%E5%88%86%E7%BB%84%EF%BC%9Agroupby-iterable-key">groupby</a></td><td align="center"><a href="#%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%90%88%E6%95%B0">连续的合数</a></td></tr><tr><td align="center"></td><td align="center">丢弃开头，直到条件成立</td><td align="center"><a href="#%E8%88%8D%E5%BC%83%E5%BC%80%E5%A4%B4%EF%BC%9Adropwhile-predicate-iterable">dropwhile</a></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">只要开头，直到条件成立</td><td align="center"><a href="#%E5%8F%AA%E8%A6%81%E5%BC%80%E5%A4%B4%EF%BC%9Atakewhile-predicate-iterable">takewhile</a></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">切片，但与列表切片不一样</td><td align="center"><a href="#%E5%88%87%E7%89%87%EF%BC%9Aislice">islice</a></td><td align="center"></td></tr></tbody></table><h1 id="官方怎么说"><a href="#官方怎么说" class="headerlink" title="官方怎么说"></a>官方怎么说</h1><blockquote><p>The module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an “iterator algebra” making it possible to construct specialized tools succinctly and efficiently in pure Python.  —— Python 3.11 documentation</p></blockquote><p>这个模块提供了一套核心的 <strong>快速</strong> 的、<strong>节省内存</strong> 的工具，这些工具可以被 “他们自己” 或者在 ”组合数学“ 中被高效地使用。他们共同形成了一个 ”迭代<strong>算法</strong>“，这使得在 <strong>纯 Python</strong> 中构建一系列专门的、简洁的、高效的工具成为可能。</p><p>（这段话明明每个单词都认识，怎么翻译起来这么难 QAQ）</p><p>因此，这个库是 Python 原生的（意味着不需要通过 <code>pip</code> 安装，<strong>只要 <code>import itertools</code> 就可以啦</strong>），同时在时间、空间上均是高效的，并且，最重要的是，这个库用起来很简洁！</p><h1 id="关于-“迭代器”-以及本文档的使用"><a href="#关于-“迭代器”-以及本文档的使用" class="headerlink" title="关于 “迭代器” 以及本文档的使用"></a>关于 “迭代器” 以及本文档的使用</h1><p>平心而论，Python 有三个 “器”：迭代器、生成器、装饰器，是相当复杂的，应该属于 Python 高级编程的范围。但如果只是 “用用”，大体是涉及不到这些高深内容的。本文介绍到的函数大多返回的不是简单的列表，而是迭代器，只有真正用到某一项时，该项才会被计算。</p><p>本文只是自己的一个记录与备忘，同时也起到了与大家分享 Python 的作用。毕竟，这么方便的东西，谁用谁上瘾。本文争取做到比中文互联网现有资料更全面、更具体，同时也更易用。</p><p>众所周知，Python 支持可变参数列表，就是同一个函数你可以传入不同数目的参数，在下述介绍中，<strong>中括号括起来的参数表示可选</strong>。</p><h1 id="组合迭代器（Combinatoric-iterators）"><a href="#组合迭代器（Combinatoric-iterators）" class="headerlink" title="组合迭代器（Combinatoric iterators）"></a>组合迭代器（Combinatoric iterators）</h1><p>这类迭代器深谙组合数学之道，组合、排列一应俱全。</p><h2 id="排列：permutations-p-r"><a href="#排列：permutations-p-r" class="headerlink" title="排列：permutations(p[, r])"></a>排列：permutations(p[, r])</h2><p><code>p</code> 是一个可迭代的对象（如字符串、列表等等），函数返回的迭代器可以生成 <code>p</code> 中元素的 <strong>排列</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.permutations(<span class="hljs-string">&quot;ABCD&quot;</span>):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;)<br>(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;D&#x27;, &#x27;C&#x27;)<br>(&#x27;A&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;D&#x27;)<br>(&#x27;A&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;B&#x27;)<br>... ...<br>(&#x27;D&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;B&#x27;)<br>(&#x27;D&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;A&#x27;)<br></code></pre></td></tr></table></figure><p><strong>其中，<code>i</code> 的类型是元组，可以使用 <code>list(i)</code> 将其转变为熟悉的列表，或者使用 <code>&quot;&quot;.join(i)</code> 将他们连成字符串（仅限字符串型的迭代）。</strong></p><p>若指定参数 <code>r</code>，则表示选取的元素个数。<strong>若 <code>r &gt; len(p)</code>，则不会有任何结果；若 <code>r == 0</code>，则循环会被执行一次，并得到一个空的元组。</strong> 后续的几个工具同理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.permutations(<span class="hljs-string">&quot;ABC&quot;</span>, <span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">(&#x27;A&#x27;, &#x27;B&#x27;)<br>(&#x27;A&#x27;, &#x27;C&#x27;)<br>(&#x27;B&#x27;, &#x27;A&#x27;)<br>(&#x27;B&#x27;, &#x27;C&#x27;)<br>(&#x27;C&#x27;, &#x27;A&#x27;)<br>(&#x27;C&#x27;, &#x27;B&#x27;)<br></code></pre></td></tr></table></figure><h2 id="组合：combinations-p-r"><a href="#组合：combinations-p-r" class="headerlink" title="组合：combinations(p, r)"></a>组合：combinations(p, r)</h2><p>组合，当然要指定调出多少个元素啦，毕竟 $C_n^n&#x3D;1$，就没有意义了吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.combinations(<span class="hljs-string">&quot;ABC&quot;</span>, <span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">(&#x27;A&#x27;, &#x27;B&#x27;)<br>(&#x27;A&#x27;, &#x27;C&#x27;)<br>(&#x27;B&#x27;, &#x27;C&#x27;)<br></code></pre></td></tr></table></figure><blockquote><p>注意，这里的 ”顺序“ 是按照你给的 <code>p</code> 中元素的顺序来的，</p></blockquote><h2 id="可重复的组合：combinations-with-replacement-p-r"><a href="#可重复的组合：combinations-with-replacement-p-r" class="headerlink" title="可重复的组合：combinations_with_replacement(p, r)"></a>可重复的组合：combinations_with_replacement(p, r)</h2><p>同 ”组合“ 是一个道理，但是可重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.combinations_with_replacement(<span class="hljs-string">&quot;ABC&quot;</span>, <span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">(&#x27;A&#x27;, &#x27;A&#x27;)<br>(&#x27;A&#x27;, &#x27;B&#x27;)<br>(&#x27;A&#x27;, &#x27;C&#x27;)<br>(&#x27;B&#x27;, &#x27;B&#x27;)<br>(&#x27;B&#x27;, &#x27;C&#x27;)<br>(&#x27;C&#x27;, &#x27;C&#x27;)<br></code></pre></td></tr></table></figure><h2 id="笛卡尔积：product-p-q-…-repeat-x3D-1"><a href="#笛卡尔积：product-p-q-…-repeat-x3D-1" class="headerlink" title="笛卡尔积：product(p, q, … [repeat&#x3D;1])"></a>笛卡尔积：product(p, q, … [repeat&#x3D;1])</h2><p>计算若干个可迭代对象的笛卡尔积，给个例子就明白是怎么算的啦（以 $\times$ 为符号）：</p><p>$$[a, b, c, d] \times [x, y, z] &#x3D; [ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz]$$</p><p>就相当于两层 <code>for</code> 循环。当然，Python 并不会真将这些元素乘起来，而是会返回一个元组，将它们组合起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">(1, 3)<br>(1, 4)<br>(1, 5)<br>(2, 3)<br>(2, 4)<br>(2, 5)<br>(3, 3)<br>(3, 4)<br>(3, 5)<br></code></pre></td></tr></table></figure><p><code>repeat</code> 参数需要使用 ”键值对“ 的形式传入（即 <strong>显式</strong> 地指明 <code>repeat=3</code> 这样的），表示将前面所有的内容重复若干遍。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">itertools.product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>], repeat=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>就相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">itertools.product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><h1 id="无穷迭代器（Infinite-iterators）"><a href="#无穷迭代器（Infinite-iterators）" class="headerlink" title="无穷迭代器（Infinite iterators）"></a>无穷迭代器（Infinite iterators）</h1><p>顾名思义，如果不停下来，他们就会无穷无尽！（你明白为什么迭代器和普通的列表不一样了吗）</p><h2 id="循环：cycle-p"><a href="#循环：cycle-p" class="headerlink" title="循环：cycle(p)"></a>循环：cycle(p)</h2><p>一直循环，无穷无尽，会 <strong>取 <code>p</code> 中的元素</strong>，然后一直循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.cycle([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">1<br>2<br>3<br>1<br>2<br>3<br>1<br>... ...<br></code></pre></td></tr></table></figure><p>（忘了告诉你，<code>Ctrl + C</code> 可以终止程序。）</p><h2 id="重复：repeat-elem-n"><a href="#重复：repeat-elem-n" class="headerlink" title="重复：repeat(elem [,n])"></a>重复：repeat(elem [,n])</h2><p>除了可以通过参数 <code>n</code> 指定重复的次数，<code>repeat</code> 与 <code>cycle</code> 的不同之处在于，它 <strong>不会将 <code>elem</code> 拆开</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.repeat([<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>], <span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.repeat([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">[3, 5, 4]<br>[3, 5, 4]<br>[3, 5, 4]<br>[7, 8, 9]<br>[7, 8, 9]<br>... ...<br></code></pre></td></tr></table></figure><p>因为不用考虑拆开取元素的事情，所以参数 <code>elem</code> 可以是任意类型。</p><h2 id="数数：count-start-step"><a href="#数数：count-start-step" class="headerlink" title="数数：count(start, [step])"></a>数数：count(start, [step])</h2><p>从整数 <code>start</code> 开始，一直数下去，若指定 <code>step</code>，则为数数的间隔，否则为 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.count(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">9</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.count(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">16</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">5<br>6<br>7<br>8<br>9<br>10<br>5<br>7<br>9<br>11<br>13<br>15<br>17<br></code></pre></td></tr></table></figure><h1 id="有穷迭代器（Iterators-terminating-on-the-shortest-input-sequence）"><a href="#有穷迭代器（Iterators-terminating-on-the-shortest-input-sequence）" class="headerlink" title="有穷迭代器（Iterators terminating on the shortest input sequence）"></a>有穷迭代器（Iterators terminating on the shortest input sequence）</h1><p>这类迭代器会按照一定的规则进行计算，当时是可以穷尽的 ~</p><h2 id="累加：accumulate-p-func"><a href="#累加：accumulate-p-func" class="headerlink" title="累加：accumulate(p [,func])"></a>累加：accumulate(p [,func])</h2><p>顾名思义，从第一项开始累加，具体而言：<code>accumulate([1, 2, 3, 4]) --&gt; [1, 3, 6, 10]</code>。</p><p>当然，你可以通过指定 <code>func</code> 参数，来控制 “累加” 的方式，比如，传入 <code>operator.mul</code> 函数（需要导入），可以让他变成 “累乘”：<code>accumulate([1, 2, 3, 4], operator.mul) --&gt; [1, 2, 6, 24]</code>。</p><p>自定义 <code>func</code> 参数时，需要两个参数，并有一个返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_add</span>(<span class="hljs-params">total, elem</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * total + elem<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> itertools.accumulate([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], my_add):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">1<br>4<br>11<br>26<br></code></pre></td></tr></table></figure><p>每次会将之前的 “累加和” 乘以二再加上当前的元素。</p><p>在 Python 3.8 及以后，还可以以键值对的形式显式指定 <code>initial</code> 参数，表示初始量，否则初始量为 <strong>第一个元素</strong>。</p><blockquote><p>注意这里，是传递 <strong>一个函数</strong> 进去，就不能加小括号啦，不然就相当于调用这个函数了。</p></blockquote><h2 id="连接：chain-iterables"><a href="#连接：chain-iterables" class="headerlink" title="连接：chain(*iterables)"></a>连接：chain(*iterables)</h2><p>将所有的可迭代对象按顺序连起来，<strong>逐项遍历</strong>，里面的元素会被提取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">chain(<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-string">&#x27;DEF&#x27;</span>) --&gt; A B C D E F<br></code></pre></td></tr></table></figure><h2 id="同样是连接：chain-from-iterable-iterable"><a href="#同样是连接：chain-from-iterable-iterable" class="headerlink" title="同样是连接：chain.from_iterable(iterable)"></a>同样是连接：chain.from_iterable(iterable)</h2><p>其实是和上一个差不多了，但是会先提取一层元素，再连接里面的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">chain.from_iterable([<span class="hljs-string">&#x27;ABC&#x27;</span>, <span class="hljs-string">&#x27;DEF&#x27;</span>])  --&gt; A B C D E F<br></code></pre></td></tr></table></figure><h2 id="挑选压缩：compress-data-selectors"><a href="#挑选压缩：compress-data-selectors" class="headerlink" title="挑选压缩：compress(data, selectors)"></a>挑选压缩：compress(data, selectors)</h2><p>给它两个可迭代对象，一个是数据，一个用来标识当前位的数据是否选用。</p><p><code>compress([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;], [1, 0, 0, 1, 1]) --&gt; [&#39;A&#39;, &#39;D&#39;, &#39;E&#39;]</code></p><p>后一个里面的元素会被逐项计算，结果的真值用来决定对应位置的元素是否选用。</p><h2 id="按需选择：filterfalse-predicate-iterable"><a href="#按需选择：filterfalse-predicate-iterable" class="headerlink" title="按需选择：filterfalse(predicate, iterable)"></a>按需选择：filterfalse(predicate, iterable)</h2><p>给定一个函数 <code>predicate</code>，接收一个参数，返回一个真值。对于可迭代对象 <code>iterable</code> 中的每一个元素，会将其传入 <code>predicate</code> 函数，若得到的 <strong>真值为 <code>False</code>，则选用该元素</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">odd</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> itertools.filterfalse(odd, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>]):<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><p>结果如下，所有的偶数被调了出来：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">2<br>6<br>4<br></code></pre></td></tr></table></figure><h2 id="舍弃开头：dropwhile-predicate-iterable"><a href="#舍弃开头：dropwhile-predicate-iterable" class="headerlink" title="舍弃开头：dropwhile(predicate, iterable)"></a>舍弃开头：dropwhile(predicate, iterable)</h2><p>给定一个函数 <code>predicate</code>，接收一个参数，返回一个真值。对于可迭代对象 <code>iterable</code> 中的每一个元素，会 <strong>从头开始</strong> 将其传入 <code>predicate</code> 函数一一校验，返回为 <code>True</code> 时 <strong>丢弃</strong>，直到某一个元素的结果为 <code>False</code>，保留 <strong>这个元素及之后所有元素</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">small</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">5</span><br><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> itertools.dropwhile(small, [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]):<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><p>结果如下，开头的 <code>[1, 4]</code> 被丢弃，直到 <code>6 &lt; 5</code> 不成立。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">6<br>4<br>1<br></code></pre></td></tr></table></figure><h2 id="只要开头：takewhile-predicate-iterable"><a href="#只要开头：takewhile-predicate-iterable" class="headerlink" title="只要开头：takewhile(predicate, iterable)"></a>只要开头：takewhile(predicate, iterable)</h2><p>给定一个函数 <code>predicate</code>，接收一个参数，返回一个真值。对于可迭代对象 <code>iterable</code> 中的每一个元素，会 <strong>从头开始</strong> 将其传入 <code>predicate</code> 函数一一校验，返回为 <code>True</code> 时 <strong>取用</strong>，直到某一个元素的结果为 <code>False</code>，<strong>直接丢弃</strong> 这个元素及 <strong>之后所有元素</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">small</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">5</span><br><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> itertools.takewhile(small, [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>]):<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><p>结果如下，开头的 <code>[1, 4]</code> 被选用，直到 <code>6 &lt; 5</code> 不成立，直接丢弃元素 <code>6</code> 及后面所有元素。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1<br>4<br></code></pre></td></tr></table></figure><h2 id="切片：islice"><a href="#切片：islice" class="headerlink" title="切片：islice()"></a>切片：islice()</h2><p>有两种形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">itertools.islice(iterable, stop)<br>itertools.islice(iterable, start, stop[, step])<br></code></pre></td></tr></table></figure><p>除了不能使用负值，同正常的列表切片一致。若 <code>stop</code> 被指定为 <code>None</code>，则会一直到结尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">islice(<span class="hljs-string">&#x27;ABCDEFG&#x27;</span>, <span class="hljs-number">2</span>)           <span class="hljs-comment">#  --&gt; A B</span><br>islice(<span class="hljs-string">&#x27;ABCDEFG&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)        <span class="hljs-comment">#  --&gt; C D</span><br>islice(<span class="hljs-string">&#x27;ABCDEFG&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">None</span>)     <span class="hljs-comment">#  --&gt; C D E F G</span><br>islice(<span class="hljs-string">&#x27;ABCDEFG&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">#  --&gt; A C E G</span><br></code></pre></td></tr></table></figure><h2 id="邻接配对：pairwise-iterable-【Python-geqslant-3-10-】"><a href="#邻接配对：pairwise-iterable-【Python-geqslant-3-10-】" class="headerlink" title="邻接配对：pairwise(iterable) 【Python $\geqslant 3.10$】"></a>邻接配对：pairwise(iterable) 【Python $\geqslant 3.10$】</h2><p>两个两个捆起来返回，当输入的可迭代对象元素数少于两个时，将为空。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> itertools.pairwise(<span class="hljs-string">&quot;ABCDEF&quot;</span>):<br>    <span class="hljs-built_in">print</span>(pair)<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">(&#x27;A&#x27;, &#x27;B&#x27;)<br>(&#x27;B&#x27;, &#x27;C&#x27;)<br>(&#x27;C&#x27;, &#x27;D&#x27;)<br>(&#x27;D&#x27;, &#x27;E&#x27;)<br>(&#x27;E&#x27;, &#x27;F&#x27;)<br></code></pre></td></tr></table></figure><h2 id="邻接分组：groupby-iterable-key"><a href="#邻接分组：groupby-iterable-key" class="headerlink" title="邻接分组：groupby(iterable[, key])"></a>邻接分组：groupby(iterable[, key])</h2><p><code>groupby</code> 可以将 <strong>相邻</strong> 的、<strong>相同</strong> 的元素给挑选出来，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">for</span> k, g <span class="hljs-keyword">in</span> itertools.groupby(<span class="hljs-string">&quot;AAAABBBCCDAABBB&quot;</span>):<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-built_in">list</span>(g))<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;]<br>B [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]<br>C [&#x27;C&#x27;, &#x27;C&#x27;]<br>D [&#x27;D&#x27;]<br>A [&#x27;A&#x27;, &#x27;A&#x27;]<br>B [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]<br></code></pre></td></tr></table></figure><p>调用 <code>groupby</code> 会得到两样东西，第一个为 ”键“（key），第二个为一个分组对象，转化成列表便如上所示。它是将相邻的东西给挑出来，</p><p><code>key</code> 参数接受一个函数，这个函数用来根据元素算出一个 ”键“，作为分组的依据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">odd</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> k, g <span class="hljs-keyword">in</span> itertools.groupby([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>], odd):<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-built_in">list</span>(g))<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">False [2]<br>True [3, 5, 1]<br>False [6, 4, 2]<br>True [3, 9]<br></code></pre></td></tr></table></figure><p>根据文档的建议，你可以使用相同的 <code>key</code> 对传入数据先进行排序，当然还是要看具体的需求啦。</p><h2 id="”复制“-迭代器：tee-iterable-n-x3D-2"><a href="#”复制“-迭代器：tee-iterable-n-x3D-2" class="headerlink" title="”复制“ 迭代器：tee(iterable[, n&#x3D;2])"></a>”复制“ 迭代器：tee(iterable[, n&#x3D;2])</h2><p>将给定的可迭代对象复制 <code>n</code> 份。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>it1, it2, it3 = itertools.tee([<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>], <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(it1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(it2))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(it3))<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">[3, 1, 4, 1, 5]<br>[3, 1, 4, 1, 5]<br>[3, 1, 4, 1, 5]<br></code></pre></td></tr></table></figure><h2 id="高级-map：starmap-function-iterable"><a href="#高级-map：starmap-function-iterable" class="headerlink" title="高级 map：starmap(function, iterable)"></a>高级 map：starmap(function, iterable)</h2><p>类似与原版的 <code>map</code>，但是会给 <code>iterable</code> <strong>中的</strong> 元素 <strong>解一次包</strong>。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">starmap(<span class="hljs-built_in">pow</span>, [(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">10</span>, <span class="hljs-number">3</span>)]) --&gt; <span class="hljs-number">32</span> <span class="hljs-number">9</span> <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>就相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">pow</span>(*(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)), <span class="hljs-built_in">pow</span>(*(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)), <span class="hljs-built_in">pow</span>(*(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>也即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>), <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="配对合并：zip-longest-iterables-fillvalue-x3D-None"><a href="#配对合并：zip-longest-iterables-fillvalue-x3D-None" class="headerlink" title="配对合并：zip_longest(*iterables[, fillvalue&#x3D;None])"></a>配对合并：zip_longest(*iterables[, fillvalue&#x3D;None])</h2><p>类似于原版的 <code>zip</code>，但是组合会一直进行到最长的为止。缺失的元素用 <code>fillvalue</code> 补齐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(itertools.zip_longest([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])))<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[(1, 3), (2, 4)]<br>[(1, 3), (2, 4), (None, 5)]<br></code></pre></td></tr></table></figure><h1 id="例题与应用"><a href="#例题与应用" class="headerlink" title="例题与应用"></a>例题与应用</h1><h2 id="打印全排列"><a href="#打印全排列" class="headerlink" title="打印全排列"></a>打印全排列</h2><p>编写一个函数，给定正整数 <code>n</code>（$1 \leqslant n \leqslant 15$），打印输出 $1 \sim n$ 的全排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">full_perm</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> itertools.permutations(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)):<br>        <span class="hljs-built_in">print</span>(*tup)<br><br>full_perm(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><ul><li><p><code>range</code> 也属于可迭代对象，传入 <code>permutations</code> 可以对 <code>[1, 2, 3 .. n]</code> 进行全排列。</p></li><li><p>第 5 行的 <code>*</code> 号表示解包运算（跟指针、地址没有关系哈），例如：<code>tup = (5, 4, 3, 2, 1)</code> 的时候，<code>print(tup)</code> 打印的结果是 <code>(5, 4, 3, 2, 1)</code>，是按照元组打印的；但是解一下包，就相当于 <code>print(5, 4, 3, 2, 1)</code>，就把一个元组拆成了五个参数，<code>print</code> 会自动加空格间隔，结果为 <code>5 4 3 2 1</code>。</p></li><li><p>第 7 行是函数调用，有同学写 Python 就搞不明白了，定义了函数却不调用，自然不会有结果啦。</p></li></ul><p>上述程序运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">1 2 3 4 5<br>1 2 3 5 4<br>1 2 4 3 5<br>... ...<br>5 4 3 1 2<br>5 4 3 2 1<br></code></pre></td></tr></table></figure><h2 id="最接近的和"><a href="#最接近的和" class="headerlink" title="最接近的和"></a>最接近的和</h2><p>编写一个函数，给定一个由不超过 $65536$ 的正整数组成的列表 <code>lst</code>，从中选取 <code>m</code> 个数（$m \leqslant 5$），使他们的和最接近某一给定的正整数 <code>num</code> （$num \leqslant 300000$），请求出这个最接近的和（答案不唯一的话，输出任一个即可）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">near_sum</span>(<span class="hljs-params">lst: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = -<span class="hljs-number">1000000</span>  <span class="hljs-comment"># 记录答案，初始化为一个很小负数，确保一定是最远的</span><br>    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> itertools.combinations(lst, m):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(num - <span class="hljs-built_in">sum</span>(tup)) &lt; <span class="hljs-built_in">abs</span>(num - res):<br>            res = <span class="hljs-built_in">sum</span>(tup)<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-built_in">print</span>(near_sum([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>], <span class="hljs-number">3</span>, <span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><ul><li><p>为什么不能简单将 <code>res</code> 初始化为 <code>0</code>？比如，给定 <code>num == 1</code>，而 <code>lst</code> 中的数字都很大，那么，<code>0</code> 不就成 “最接近” 了嘛，这样肯定是不对的。</p></li><li><p>第 5 行的 <code>abs</code> 和 <code>sum</code> 是 Python 的两个内置函数，不用导入数学库，它们分别求得绝对值与和（对于一切你觉得可以求的东西都可以求，比如给一个列表求和等等）。</p></li></ul><p>上述程序运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">11 （9 也是正确答案）<br></code></pre></td></tr></table></figure><h2 id="等差时间"><a href="#等差时间" class="headerlink" title="等差时间"></a>等差时间</h2><p>编写一个函数，求出 0 时 0 分 0 秒 至 <code>h</code> 时 <code>m</code> 分 <code>s</code> 秒 之间，有多少个时刻满足时分秒成等差数列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ap_time_for</span>(<span class="hljs-params">h: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, s: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> h1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> m1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> s1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(s + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> h1 + s1 == m1 * <span class="hljs-number">2</span>:<br>                    res += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ap_time</span>(<span class="hljs-params">h: <span class="hljs-built_in">int</span>, m: <span class="hljs-built_in">int</span>, s: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> tup <span class="hljs-keyword">in</span> itertools.product(<span class="hljs-built_in">range</span>(h + <span class="hljs-number">1</span>), <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>), <span class="hljs-built_in">range</span>(s + <span class="hljs-number">1</span>)):<br>        h1, m1, s1 = tup<br>        <span class="hljs-keyword">if</span> h1 + s1 == m1 * <span class="hljs-number">2</span>:<br>            res += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-built_in">print</span>(get_ap_time(<span class="hljs-number">16</span>, <span class="hljs-number">10</span>, <span class="hljs-number">59</span>))<br></code></pre></td></tr></table></figure><ul><li><p>上面提供了两种写法，使用 <code>for</code> 循环嵌套看上去更加简洁，但是缩进太深，容易混乱，而且还有一个更重要的是，前一种写法的缩进层数是 <strong>固定</strong> 的，无法动态调整，而使用 <code>product</code>，可以用一些方法（比如解包二维列表得到的若个以为列表），动态调整。</p></li><li><p>第 14-15 行，还可以这样写：<code>for h1, m1, s1 in itertools.product(...):</code>，更加优雅。</p></li></ul><p>上述程序运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">115<br></code></pre></td></tr></table></figure><h2 id="计算阶乘和"><a href="#计算阶乘和" class="headerlink" title="计算阶乘和"></a>计算阶乘和</h2><p>编写一个函数，计算 $1!+2!+\cdots+n!$ 的结果，其中 $n$ 为给定正整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">import</span> operator<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fac_sum</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(itertools.accumulate(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>), operator.mul))<br><br><span class="hljs-built_in">print</span>(fac_sum(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><ul><li><p>上述例子只用了一行便解决问题，其中，通过将 ”累加器“ 指定为 ”乘“，得到了各个数的阶乘，最后直接求和。因为 <code>accumulate</code> 是累加求的，所以时间复杂度相当可观。更重要的是，写着爽呀！</p></li><li><p><code>operator.mul</code> 是内置的函数，就表示通常意义的 <code>*</code>。</p></li></ul><p>上述程序运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">153<br></code></pre></td></tr></table></figure><h2 id="连续的合数"><a href="#连续的合数" class="headerlink" title="连续的合数"></a>连续的合数</h2><p>编写一个函数，统计 $2 \sim n$ 中，最长出现了多少个连续的合数，其中，$10 \leqslant n \leqslant 100000$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">prime</span>(<span class="hljs-params">x</span>):<br>    i = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> i * i &lt;= x:<br>        <span class="hljs-keyword">if</span> x % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">straight_composite</span>(<span class="hljs-params">n</span>):<br>    lst = []<br>    <span class="hljs-keyword">for</span> _, g <span class="hljs-keyword">in</span> itertools.groupby(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>), prime):<br>        lst.append(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(g)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lst)<br><br><span class="hljs-built_in">print</span>(straight_composite(<span class="hljs-number">27</span>))<br></code></pre></td></tr></table></figure><ul><li><p>考虑到连续的素数只有 2 和 3，所以没有对素数与合数加以区分，连续的合数会被自动分组，单个的素数也自成一组，然后求出每个归组列表的长度，存入一个新的列表，然后直接求其最大值。</p></li><li><p>注意到，<code>for</code> 循环中出现了一个 <code>_</code>，这个也是一个合法的变量名，并且有特殊的 <strong>语义</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="什么是 ”语义“，按照我的理解，就是这段代码想要表达的意思，与语法无关。Python 中有很多写法都能达到相同的效果，但它们可能各有各的语义，这个需要去感受一下。">[1]</span></a></sup>，表示这个变量我用不到，就是占个位置。</p></li></ul><p>上述程序运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">4<br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>什么是 ”语义“，按照我的理解，就是这段代码想要表达的意思，与语法无关。Python 中有很多写法都能达到相同的效果，但它们可能各有各的语义，这个需要去感受一下。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Python 教程</category>
      
      <category>实用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>itertools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dev 编译报错与警告信息解读</title>
    <link href="/2023/03/23/Dev-%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E4%B8%8E%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF%E8%A7%A3%E8%AF%BB/"/>
    <url>/2023/03/23/Dev-%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99%E4%B8%8E%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>本文的重点在于 “警告” 部分，编译错误大家通常较为熟悉且容易定位，只是一笔带过，并且像那些没加分号、用中文引号的，不再提及。欢迎大家补充！！！</p><p>同时，你可以通过 Ctrl+F 搜索关键词，比如 <code>implicit</code> 快速找到对应的报错或者警告信息。</p><h1 id="可以不用了解的基础知识"><a href="#可以不用了解的基础知识" class="headerlink" title="可以不用了解的基础知识"></a>可以不用了解的基础知识</h1><p>首先了解一些基本的知识。首先，Dev 只是一个 “<strong>集成开发环境</strong>”，其编译程序使用的是<code>MinGW</code><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="MinGW 是 Windows 下的基于 GCC 程序开发环境">[1]</span></a></sup> 里的 <code>gcc</code>。然后，产生一个程序有两个主要的步骤，一个叫 “<strong>编译</strong>”，一个叫 “<strong>链接</strong>”。所谓编译，是从单个代码文件生成二进制代码的过程，但是由编译生成的“<strong>中间代码</strong>”并不会含有所有函数的实现方式，比如 <code>printf</code>。这就需要“链接”，链接器会从“库”或者其他生成的中间代码中寻找这些函数的实现方式，并将它们“链接”进来。</p><p>因此，常见的“编译错误”会有两类：链接错误和编译错误。</p><h1 id="链接错误"><a href="#链接错误" class="headerlink" title="链接错误"></a>链接错误</h1><p>在 Dev 中，链接错误的最后会有如下提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">****\collect2.exe  [Error] ld returned 1 exit status<br></code></pre></td></tr></table></figure><blockquote><p>原文解读：<code>ld</code> 是链接器的名字，<code>collect2.exe</code> 是对其的封装。链接器返回了 1 这个退出状态码，那自然是异常情况啦，因为正常退出一定返回 0。</p></blockquote><p>很多同学也许会条件反射地认为，这是 <strong>“没有把运行中的程序关掉”</strong> 导致的，对，但不完全是这样。其实很多情况都会导致链接错误的。</p><h2 id="无法生成-exe-程序"><a href="#无法生成-exe-程序" class="headerlink" title="无法生成 exe 程序"></a>无法生成 exe 程序</h2><p>为什么无法生成？可能是因为 <strong>之前开的程序没有关掉</strong>，也可能是有同名的文件夹（比如目录下有一个 <strong>文件夹</strong> 叫 <code>test.exe</code>，但是这个原因也太逆天了吧）。报错信息为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">****\bin\ld.exe    cannot open output file ****.exe: Permission denied<br>****\collect2.exe  [Error] ld returned 1 exit status<br></code></pre></td></tr></table></figure><blockquote><p>原文解读：无法打开输出文件的原因是“拒绝访问”。原来的程序开着呢，怎么往里面覆盖数据呢。</p></blockquote><h2 id="未定义的引用"><a href="#未定义的引用" class="headerlink" title="未定义的引用"></a>未定义的引用</h2><p>有时候你 <strong>把函数名字写错</strong> 了，虽然可以正常编译，但是链接不了，因为找不到对应的链接库。报错信息为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;line&gt;   ****.c    undefined reference to `&lt;name&gt;&#x27;<br>****\collect2.exe  [Error] ld returned 1 exit status<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    getchr();  <span class="hljs-comment">// undefined reference to &#x27;getchr&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>原文解读：对 … 未定义的引用。这种报错很容易懂，双击也可以跳转。</p></blockquote><h2 id="没有-main-函数"><a href="#没有-main-函数" class="headerlink" title="没有 main 函数"></a>没有 main 函数</h2><p>大概也许是写错了吧…</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">****\crt0_c.c      undefined reference to `WinMain&#x27;<br>****\collect2.exe  [Error] ld returned 1 exit status<br></code></pre></td></tr></table></figure><p>你看这报错信息，一点 <code>main</code> 的影子都没有，它报的是 “未定义对 <code>WinMain</code> 的引用”，<code>WinMain</code> 是 Windows 程序的入口函数，至于它是怎样与 <code>main</code> 函数联系起来的，就太复杂了（其实是我不知道，网上资料有限啦 QAQ）。版本高一些的 Dev 会直接报 “没有 main 函数” 的错误。</p><blockquote><p>原文解读：我只能告诉你，<code>crt</code> 是 <code>C Runtime</code> 的缩写，是与 C 的运行时相关的文件，而且报错的 <code>crt0_c.c</code> 在机器上是找不到的。</p></blockquote><h2 id="找到一个或多个重定义符号"><a href="#找到一个或多个重定义符号" class="headerlink" title="找到一个或多个重定义符号"></a>找到一个或多个重定义符号</h2><p>此类编译错误一般是在多文件编程中，当头文件被重复包含且没做保护、头文件这种有定义行为时出现。</p><h1 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h1><p>编译错误一般是源代码出现了语法层面的问题。</p><h2 id="变量未声明"><a href="#变量未声明" class="headerlink" title="变量未声明"></a>变量未声明</h2><p>这个是比较常见也比较显然的错误，信息如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Error] &#x27;****&#x27; undeclared (first use in this function)<br></code></pre></td></tr></table></figure><h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>当你在同一个 <strong>局部</strong> 作用域中，不小心声明了两个重名变量，会生成此错误。报错信息如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[Error] redeclaration of &#x27;****&#x27; with no linkage<br>[Note] previous declaration of &#x27;****&#x27; was here<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i;      <span class="hljs-comment">// [Note] previous declaration of &#x27;i&#x27; was here</span><br>    <span class="hljs-comment">// ... ...</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">// [Error] redeclaration of &#x27;i&#x27; with no linkage</span><br>    <span class="hljs-comment">// ... ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意！下面的代码不会报错（std $\geqslant$ c99），但有可能影响程序的逻辑。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">// ... ...</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>        <span class="hljs-comment">// ... ...</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义的是不同类型的，则会报错为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Error] conflicting types for &#x27;****&#x27;<br></code></pre></td></tr></table></figure><p>还有一类重复声明，即，定义了 <strong>与库函数重名</strong> 的 <strong>全局变量</strong>，会生成以下报错信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Error] &#x27;****&#x27; redeclared as different kind of symbol<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-built_in">pow</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，在较低的 C 语言标准中，在使用数学库时，全局变量不可以使用 <code>y0</code> <code>y1</code> 等等，因为它们是 <code>math.h</code> 中的函数。</p><h2 id="数组使用了不完整的元素类型"><a href="#数组使用了不完整的元素类型" class="headerlink" title="数组使用了不完整的元素类型"></a>数组使用了不完整的元素类型</h2><p>当你的函数的参数列表，或者变量定义中使用了高维数组，一定要填入除了第一个维度以外的其余维度的尺寸。否则会生成如下信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Error] array type has incomplete element type<br></code></pre></td></tr></table></figure><p>例如，下面的例子有两个地方的错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[][])</span>;         <span class="hljs-comment">// 可以写成 int arr[][10]</span><br><br><span class="hljs-type">int</span> a[][] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;;  <span class="hljs-comment">// 至少应该是 int a[][2]</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>原文解读：它这里说的 “不完整”，是指哪个数组用了不完整的类型？是第一个方括号所指的那个数组。比如 <code>int a[][2]</code> 中，每一个 <code>a[i]</code> 都是一个 <code>int[2]</code> 的数组，如果这个 <code>2</code> 不写，那么每一个 <code>a[i]</code> 就是 “<strong>不完整</strong>” 的，因为没有确定的长度。</p></blockquote><p>此外，当其中使用了一些没有被定义、或者在后面才被定义，也会生产这个错误。这类错误多出现在函数定义中。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">node_t</span> arr[<span class="hljs-number">10</span>])</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span> &#123;</span><br><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="只有结构体和联合才有成员"><a href="#只有结构体和联合才有成员" class="headerlink" title="只有结构体和联合才有成员"></a>只有结构体和联合才有成员</h2><p>在使用结构体时，一定要区分 <code>.</code> 和 <code>-&gt;</code>。</p><p>将 <code>.</code> 错用为 <code>-&gt;</code> 会生成如下错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Error] invalid type argument of &#x27;-&gt;&#x27; (have &#x27;****&#x27;)<br></code></pre></td></tr></table></figure><p>将 <code>-&gt;</code> 错用为 <code>.</code> 会成成如下错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Error] request for member &#x27;****&#x27; in something not a structure or union<br></code></pre></td></tr></table></figure><p>同时，后一条报错会出现在更广泛的场景中，比如把逗号误用 <code>.</code> 的时候。</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo_t</span> &#123;</span><br><span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo_t</span> <span class="hljs-title">obj</span> =</span> &#123;<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo_t</span> *<span class="hljs-title">ptr</span> =</span> &amp;obj;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, obj-&gt;num);  <span class="hljs-comment">// 应该用 .</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ptr.num);   <span class="hljs-comment">// 应该用 -&gt;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结尾应该是声明或语句"><a href="#结尾应该是声明或语句" class="headerlink" title="结尾应该是声明或语句"></a>结尾应该是声明或语句</h2><p>这种报错一般出现在最后一行，并且几乎都是前面的问题。比如，哪里括号弄错了，引号漏掉了等等，甚至没定义、遗漏头文件也可能导致这个错误。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Error] expected declaration or statement at end of input<br></code></pre></td></tr></table></figure><h1 id="编译警告"><a href="#编译警告" class="headerlink" title="编译警告"></a>编译警告</h1><p>通常情况下，Dev 并不会提供太多警告信息，少数的警告有：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] implicit declaration of function &#x27;****&#x27; [-Wimplicit-function-declaration]<br></code></pre></td></tr></table></figure><p>除了在较高的 C++ std 中使用 <code>gets</code> 会显示此警告外，基本是调用函数时名字写错了。</p><h2 id="开启警告与警告信息解读"><a href="#开启警告与警告信息解读" class="headerlink" title="开启警告与警告信息解读"></a>开启警告与警告信息解读</h2><p>事实上，通过修改编译选项，可以开启更多警告。具体操作为：依次点击 <strong>工具 -&gt; 编译选项 -&gt; 勾选“编译时加入以下命令”</strong>，并在其中添加 <code> -Wall -Wextra</code>，注意，不同的参数之间需要空格隔开。</p><p><img src="/img/dev-wall.png" alt="添加参数，注意大小写与空格"></p><p>注意！开启 <code>-Wall</code> 后，部分低版本 Dev 可能无法识别 <code>%lld</code> 的占位符，并会显示两条警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] unknown conversion type character &#x27;l&#x27; in format [-Wformat=]<br>[Warning] too many arguments for format [-Wformat-extra-args]<br></code></pre></td></tr></table></figure><p>分别表示：位置的占位符 <code>%l</code> 与 太多格式化参数。解决方法：<strong>忽略</strong>这两条警告，或者使用 <strong><code>%I64d</code></strong> 代替 <code>%lld</code>，或者不开 <code>-Wall</code>。</p><p>我们看一下下面的这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span>    a, b, t, res;<br>    <span class="hljs-type">double</span> c;<br>    <span class="hljs-type">char</span>   d;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<br>    res += <span class="hljs-number">100</span>;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, b, &amp;c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%d\n&quot;</span>, b);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt;= c &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c in between 0 and 1\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;d);<br>    <span class="hljs-keyword">if</span> (d = <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d is &#x27;a&#x27;\n&quot;</span>);<br>    &#125;<br><br>    t = <span class="hljs-number">3.14</span>;<br>    t = c;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/dev-warning.png" alt="各种报错信息（行数不一致）"></p><h2 id="变量未初始化"><a href="#变量未初始化" class="headerlink" title="变量未初始化"></a>变量未初始化</h2><p>并不是说定义变量时一定要同步初始化，</p><p>警告信息为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] &#x27;****&#x27; is used uninitialized in this function [-Wuninitialized]<br></code></pre></td></tr></table></figure><p>例如上述例子的第 8 行与第 9 行。变量不初始化可能 <strong>本地运行完全正确</strong>，但是提交会 WA，较为隐蔽！全局变量不初始化不会生成此警告，因为全局变量会自动初始化为 0.</p><h2 id="占位符不匹配"><a href="#占位符不匹配" class="headerlink" title="占位符不匹配"></a>占位符不匹配</h2><p>不匹配的情况有多种，比如，<strong>匹配错误</strong>、<strong>忘记 <code>&amp;</code><strong>、</strong>数目不对</strong>。</p><p>类型不匹配的报错信息如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] format &#x27;**&#x27; expects argument of type &#x27;**&#x27;, but argument * has type &#x27;**&#x27; [-Wformat=]<br></code></pre></td></tr></table></figure><p>格式占位符 “**” 期待一个 ** 类型的参数，但是第 * 个参数的类型是 **。例如上面的例子的第 11 行，遗漏了一个取地址符，同时写错了一个。此错误同样较为隐蔽。</p><p>占位符数目不一致的报错信息如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] format &#x27;**&#x27; expects a matching &#x27;**&#x27; argument [-Wformat=]<br>[Warning] too many arguments for format [-Wformat-extra-args]<br></code></pre></td></tr></table></figure><p>前者表示格式占位符 “**” 还需要一个 ** 类型的变量，也即数目少了。后者表示参数过多。</p><h2 id="相等写成赋值"><a href="#相等写成赋值" class="headerlink" title="相等写成赋值"></a>相等写成赋值</h2><p>一般在 <code>if</code> 语句中，很少会直接使用赋值语句作为条件判断，因此，一旦你这样使用，会生成如下警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] suggest parentheses around assignment used as truth value [-Wparentheses]<br></code></pre></td></tr></table></figure><p>例如上面例子的第 19 行。如果你想要消除这个警告，多套一个括号就行，这样编译器就知道你是可以这样做的。</p><h2 id="“永真式”-或者连比"><a href="#“永真式”-或者连比" class="headerlink" title="“永真式” 或者连比"></a>“永真式” 或者连比</h2><p>众所周知，C 语言不支持连比，于是编译器会这样警告你：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] comparisons like &#x27;X&lt;=Y&lt;=Z&#x27; do not have their mathematical meaning [-Wparentheses]<br></code></pre></td></tr></table></figure><p>例如上面例子的第 14 行，此外，因为这个判断是永远为 “真” 的，因此（高版本的）编译器还会有如下警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] comparison of constant &#x27;1&#x27; with boolean expression is always true [-Wbool-compare]<br></code></pre></td></tr></table></figure><p>告诉你，这个条件判断永远为真。</p><h2 id="危险的浮点转换"><a href="#危险的浮点转换" class="headerlink" title="危险的浮点转换"></a>危险的浮点转换</h2><p>高版本的编译器可以在编译选项中添加 <code>-Wfloat-conversion</code> 以开启 <strong>隐含的</strong> 浮点转换检测。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] conversion from &#x27;double&#x27; to &#x27;int&#x27; changes value (from &#x27;***&#x27; to &#x27;***&#x27;) [-Wfloat-conversion]<br></code></pre></td></tr></table></figure><p>注意，这里检查的是隐式的转换，比如上面例子的第 23 行与 24 行。如果值能够在编译器确定，编译器还会告诉你从几转变为几。使用 <strong>强制类型转换</strong> 可以告诉编译器，你是刻意这样做的，便不再警告</p><h2 id="未使用的变量"><a href="#未使用的变量" class="headerlink" title="未使用的变量"></a>未使用的变量</h2><p>也许这个看上去无关紧要，最多可能不太优雅。但是万一这个 “没有使用” 的变量是你提前规划好的呢？也许逻辑就缺失了。警告信息为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] unused variable &#x27;****&#x27; [-Wunused-variable]<br></code></pre></td></tr></table></figure><h2 id="误用逗号表达式"><a href="#误用逗号表达式" class="headerlink" title="误用逗号表达式"></a>误用逗号表达式</h2><p>当你写了一个<a href="/2022/09/09/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8/">逗号表达式</a>，却没有发挥其作用时，高版本的编译器会生成警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[Warning] left-hand operand of comma expression has no effect [-Wunused-value]<br>[Warning] right-hand operand of comma expression has no effect [-Wunused-value]<br></code></pre></td></tr></table></figure><p>告诉你，逗号表达式的左或者右操作数没有起效。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    a = <span class="hljs-number">1</span>, <span class="hljs-number">5</span>;       <span class="hljs-comment">// right-hand</span><br>    <span class="hljs-keyword">if</span> (i, j++) &#123;   <span class="hljs-comment">// left-hand</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2><p>欢迎补充喵~</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>MinGW 是 Windows 下的基于 GCC 程序开发环境<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C 语言教程</category>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Dev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【离散】从 C 到 Python 快速上手</title>
    <link href="/2023/03/19/%E3%80%90%E7%A6%BB%E6%95%A3%E3%80%91%E4%BB%8E-C-%E5%88%B0-Python-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <url>/2023/03/19/%E3%80%90%E7%A6%BB%E6%95%A3%E3%80%91%E4%BB%8E-C-%E5%88%B0-Python-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Chap-00-说在前面"><a href="#Chap-00-说在前面" class="headerlink" title="Chap.00 说在前面"></a>Chap.00 说在前面</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此文用到的 <strong>安装包</strong>、<strong>测试程序</strong>、<strong>习题参考程序</strong> 均可以通过<a href="https://bhpan.buaa.edu.cn/link/D158B53EA534C118214A2B13759F94AB">这个链接</a>得到。有效期限：2024-04-01 23:59，访问密码：<code>vcFx</code>。</p><p>此文默认读者已经掌握并理解了基本的 C 语法，并对编程的基本知识了解。为了更好地解决离散作业中的编程题，此文会避重就轻，以减轻不必要的负担。但强烈建议有兴趣并且学有余力的读者系统地学习 Python。此文会持续更新，以确保能够应对本周的离散作业。</p><p><a href="#chap-01-%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87">第一章</a>，我们安装了 Python 的开发与运行环境，介绍了相关文件的作用，并完成了第一个 “Hello world” 程序。<a href="#chap-02-%E5%8F%98%E9%87%8F%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F">第二章</a>，我们介绍了 Python 可变的类型，以及一些新颖的类型、运算。<a href="#chap-03-%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">第三章</a>，我们了解了 Python 函数的定义语法。<a href="#chap-04-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF">第四章</a>，我们学习了 Python 的分支语句与循环语句，特别介绍了 Python 强大的 <code>for</code> 循环。<a href="#chap-05-%E5%88%97%E8%A1%A8%E4%B8%8E%E5%88%97%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86">第五章</a>，我们了解了列表的定义、扩增、遍历。<a href="#chap-06-%E6%8B%AF%E6%95%91%E7%A6%BB%E6%95%A3%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%9D%80%E5%99%A8%EF%BC%9Aeval-%E5%87%BD%E6%95%B0">第六章</a>，我们学习了 <code>eval</code> 函数的简单用法。<a href="#Chap-07-%E7%9C%9F%E5%80%BC%E8%BF%90%E7%AE%97%E3%80%81%E7%9C%9F%E5%80%BC%E8%A1%A8">第七章</a>，联系了离散数学课程的实际，通过几个例子来展示 Python 的应用。最后，我还提供了各个练习的<a href="#chap-ex-%E7%BB%83%E4%B9%A0%E8%A7%A3%E7%AD%94">参考代码</a>，以及仅作补充、不做要求的<a href="#chap-xx-%E9%99%84%E5%BD%95">附录</a>。</p><h2 id="便捷跳转"><a href="#便捷跳转" class="headerlink" title="便捷跳转"></a>便捷跳转</h2><table><thead><tr><th align="center">习题</th><th align="center">跳转到题目</th><th align="center">跳转到解答</th></tr></thead><tbody><tr><td align="center">01 判断闰年</td><td align="center"><a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%88Ex-01-%E5%88%A4%E6%96%AD%E9%97%B0%E5%B9%B4%EF%BC%89">Ex.01</a></td><td align="center"><a href="#01-%E5%88%A4%E6%96%AD%E9%97%B0%E5%B9%B4">Ex.01</a></td></tr><tr><td align="center">02 判断素数</td><td align="center"><a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%88Ex-02-%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0%EF%BC%89">Ex.02</a></td><td align="center"><a href="#02-%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0">Ex.02</a></td></tr><tr><td align="center">03 计算阶乘</td><td align="center"><a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%88Ex-03-%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%EF%BC%89">Ex.03</a></td><td align="center"><a href="#03-%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98">Ex.03</a></td></tr><tr><td align="center">04 奇偶判断</td><td align="center"><a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%88Ex-04-%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD%EF%BC%89">Ex.04</a></td><td align="center"><a href="#04-%E5%A5%87%E5%81%B6%E5%88%A4%E6%96%AD">Ex.04</a></td></tr><tr><td align="center">05 列表求和</td><td align="center"><a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%88Ex-05-%E5%88%97%E8%A1%A8%E6%B1%82%E5%92%8C%EF%BC%89">Ex.05</a></td><td align="center"><a href="#05-%E5%88%97%E8%A1%A8%E6%B1%82%E5%92%8C">Ex.05</a></td></tr><tr><td align="center">06 计算结果</td><td align="center"><a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%88Ex-06-%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%EF%BC%89">Ex.06</a></td><td align="center"><a href="#06-%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C">Ex.06</a></td></tr><tr><td align="center">07 可满足式</td><td align="center"><a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%88Ex-07-%E5%8F%AF%E6%BB%A1%E8%B6%B3%E5%BC%8F%EF%BC%88%E4%BD%9C%E4%B8%9A%EF%BC%89%EF%BC%89">Ex.07</a></td><td align="center">这可是作业呀</td></tr><tr><td align="center">08 析取式数</td><td align="center"><a href="#%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%88Ex-08-%E6%9E%90%E5%8F%96%E5%BC%8F%E6%95%B0%EF%BC%88%E4%BD%9C%E4%B8%9A%EF%BC%89%EF%BC%89">Ex.08</a></td><td align="center">这可是作业呀</td></tr></tbody></table><table><thead><tr><th align="center">知识点</th><th align="center">跳转链接</th></tr></thead><tbody><tr><td align="center">Python 关键字列表</td><td align="center"><a href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D">变量命名</a></td></tr><tr><td align="center">简单的字符串运算</td><td align="center"><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97%EF%BC%88%E5%90%8E%E7%BB%AD%E4%BC%9A%E5%8D%95%E5%88%97%E4%B8%80%E8%8A%82%EF%BC%89">字符串运算</a></td></tr><tr><td align="center">列表元素的增删</td><td align="center"><a href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E4%B8%8E%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">插入元素与删除元素</a></td></tr><tr><td align="center">三目运算符</td><td align="center"><a href="#if-else%E8%BF%90%E7%AE%97%E7%AC%A6">if-else运算符</a></td></tr></tbody></table><h1 id="Chap-01-前置准备"><a href="#Chap-01-前置准备" class="headerlink" title="Chap.01 前置准备"></a>Chap.01 前置准备</h1><h2 id="Python-是一门怎样的语言及环境的安装"><a href="#Python-是一门怎样的语言及环境的安装" class="headerlink" title="Python 是一门怎样的语言及环境的安装"></a>Python 是一门怎样的语言及环境的安装</h2><p>Python 是一门 <strong>解释型</strong> 语言，这意味着 Python 代码在执行时，由 <strong>解释器</strong> <strong>一行一行</strong> 翻译成机器语言的 <code>0</code> 和 <code>1</code>，再运行，而不是像 C 语言直接翻译出一个 <strong>可执行文件</strong>。这意味着 Python 的运行速度可能更慢，但具有更好的<strong>可移植性</strong>（这很好理解，因为针对不同系统，我们只需要安装不同的 Python 解释器就行了）。</p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile&gt;&lt;diagram id=\&quot;KsTuSB7g7Df1m90gQilt\&quot; name=\&quot;Page-1\&quot;&gt;&lt;mxGraphModel dx=\&quot;966\&quot; dy=\&quot;734\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;1169\&quot; pageHeight=\&quot;827\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;&lt;root&gt;&lt;mxCell id=\&quot;0\&quot;/&gt;&lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot;/&gt;&lt;mxCell id=\&quot;27\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;40\&quot; y=\&quot;70\&quot; width=\&quot;650\&quot; height=\&quot;620\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;2\&quot; value=\&quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;程序员\&quot; style=\&quot;shape=actor;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;320\&quot; y=\&quot;100\&quot; width=\&quot;60\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;4\&quot; value=\&quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;用户\&quot; style=\&quot;shape=actor;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;570\&quot; y=\&quot;100\&quot; width=\&quot;60\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;9\&quot; style=\&quot;edgeStyle=none;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;5\&quot; target=\&quot;8\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;5\&quot; value=\&quot;写代码\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;220\&quot; y=\&quot;210\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;6\&quot; value=\&quot;编译型语言&amp;lt;br&amp;gt;如 C / C++\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;60\&quot; y=\&quot;270\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;7\&quot; value=\&quot;解释型语言&amp;lt;br&amp;gt;如 Python\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;60\&quot; y=\&quot;550\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;13\&quot; style=\&quot;edgeStyle=none;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;8\&quot; target=\&quot;10\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;14\&quot; style=\&quot;edgeStyle=none;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;8\&quot; target=\&quot;11\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;15\&quot; style=\&quot;edgeStyle=none;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;8\&quot; target=\&quot;12\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;8\&quot; value=\&quot;编译成&amp;lt;br&amp;gt;可执行文件\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;220\&quot; y=\&quot;328.25\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;17\&quot; style=\&quot;edgeStyle=none;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0.009;entryY=0.615;entryDx=0;entryDy=0;entryPerimeter=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;10\&quot; target=\&quot;16\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;10\&quot; value=\&quot;Windows&amp;lt;br&amp;gt;编译一个版本\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;360\&quot; y=\&quot;258.25\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;18\&quot; style=\&quot;edgeStyle=none;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;11\&quot; target=\&quot;16\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;11\&quot; value=\&quot;Mac&amp;lt;br&amp;gt;编译一个版本\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;360\&quot; y=\&quot;328.25\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;19\&quot; style=\&quot;edgeStyle=none;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;12\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;mxPoint x=\&quot;540\&quot; y=\&quot;360\&quot; as=\&quot;targetPoint\&quot;/&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;12\&quot; value=\&quot;Linux&amp;lt;br&amp;gt;编译若干版本\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;360\&quot; y=\&quot;401.75\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;21\&quot; style=\&quot;edgeStyle=none;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;16\&quot; target=\&quot;20\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;16\&quot; value=\&quot;下载合适的版本\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;540\&quot; y=\&quot;328.25\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;20\&quot; value=\&quot;运行&amp;lt;b&amp;gt;&amp;lt;font color=&amp;quot;#660000&amp;quot;&amp;gt;程序&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;540\&quot; y=\&quot;210\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;26\&quot; style=\&quot;edgeStyle=none;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;22\&quot; target=\&quot;24\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;22\&quot; value=\&quot;写代码\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;290\&quot; y=\&quot;550\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;25\&quot; style=\&quot;edgeStyle=none;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=15;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;23\&quot; target=\&quot;24\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;23\&quot; value=\&quot;安装适当的&amp;lt;br&amp;gt;Python 解释器\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;540\&quot; y=\&quot;490\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;24\&quot; value=\&quot;运行&amp;lt;b&amp;gt;&amp;lt;font color=&amp;quot;#660000&amp;quot;&amp;gt;代码&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;540\&quot; y=\&quot;610\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;/root&gt;&lt;/mxGraphModel&gt;&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script><p>那么如何安装 Python 的解释器以及开发环境呢？其实很简单：</p><ol><li>双击运行安装包 <code>python-3.10.5-amd64.exe</code></li><li>按照提示勾选 <code>Add Python 3.10 to PATH</code></li><li>点击 <code>Install Now</code>，等待安装结束点击 <code>Close</code> 即可</li></ol><p><strong>请注意，第二步很重要</strong>，同时，提供给大家的安装包可能是 3.11 版本的，没啥区别的。</p><h2 id="输出一个-Hello-world"><a href="#输出一个-Hello-world" class="headerlink" title="输出一个 Hello world"></a>输出一个 Hello world</h2><h3 id="交互式运行与脚本式编程"><a href="#交互式运行与脚本式编程" class="headerlink" title="交互式运行与脚本式编程"></a>交互式运行与脚本式编程</h3><p>所谓“交互式”，大致可以理解为你写一句，Python 解释器 执行一句（当然，如果你在写代码块，比如函数体的时候，会等你写完）。而脚本式，则是把所有要执行的代码写在一个（或多个）<code>.py</code> 的文件中，然后 Python 解释器会一行一行读取、执行。交互式更加简洁、快速，而脚本式能够保存、便于修改。这里我们只设计脚本式编程。</p><h3 id="Python-的相关文件"><a href="#Python-的相关文件" class="headerlink" title="Python 的相关文件"></a>Python 的相关文件</h3><p>在安装好 Python 之后，我们会在“开始”菜单中看到这四个文件<br><img src="/img/01-01.png"></p><h4 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h4><p><code>IDLE</code> 为 Python 自带的集成开发环境，打开后是交互式环境。</p><p><img src="/img/01-02.png"></p><p>依次点击 <code>File -&gt; New File</code>（或者 <code>Ctrl + N</code>）可以新建一个文件并打开编辑窗口，我们可以在其中编写代码。注意：缩进使用 <strong>4 个空格</strong>，当然，IDLE 有自动缩进的功能；同时，除了引号内的内容，所有的标点应该使用英文标点；不要忘记两个 <code>if</code> 语句之后的英文冒号。</p><p><img src="/img/01-03.png"></p><p>保存后，依次点击 <code>Run -&gt; Run Module</code>（或者 <code>F5</code>）即可运行。</p><blockquote><p>P.S. 这一段代码与注释可以从下面的<a href="#%E7%AC%AC%E4%B8%80%E4%BB%BD%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%B3%A8%E9%87%8A">附录</a>中找到，是我之前写的教程里的，不需要深究。因为高中我选的“物化生”，并且那份教程的第一批受众是我的高中同学，所以我并没有歧视地理学科的意思。同时，Python 的 <strong>注释</strong> 为 <code>#</code> 开头。</p></blockquote><h4 id="Python-exe"><a href="#Python-exe" class="headerlink" title="Python.exe"></a>Python.exe</h4><p>图标黑黑的 <code>Python</code> 就是标准的交互式窗口了，它也负责执行脚本。</p><p><img src="/img/01-04.png"></p><h4 id="用户手册与官方文档"><a href="#用户手册与官方文档" class="headerlink" title="用户手册与官方文档"></a>用户手册与官方文档</h4><p> <code>Manuals</code> 和 <code>Module Docs</code> 为两个文档，英文的，可以查阅与参考。</p><h3 id="交互式运行"><a href="#交互式运行" class="headerlink" title="交互式运行"></a>交互式运行</h3><p>在 <code>&gt;&gt;&gt;</code> 后可以输入我们的代码，回车后就会被执行，如果出现 <code>...</code> 则表明我们的逻辑块没有结束，再按一次回车可以结束当前逻辑块的输入并运行。请注意，没有 <code>&gt;&gt;&gt;</code> 和 <code>...</code> 作为前导的，为程序的输出（如 <code>print</code> 语句括号中的内容会被‘打印’出来）。这种运行方式一般是进行一些简短代码的测试。</p><p><img src="/img/01-05.png"></p><h3 id="着手写我们的-Hello-world"><a href="#着手写我们的-Hello-world" class="headerlink" title="着手写我们的 Hello world"></a>着手写我们的 Hello world</h3><p>打开 <code>IDLE</code>，新建文件，输入代码，保存运行！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="知识点小记（No-01）"><a href="#知识点小记（No-01）" class="headerlink" title="知识点小记（No. 01）"></a>知识点小记（No. 01）</h4><ol><li><p>注意不要写成 <code>printf</code>，行尾不用加分号。</p></li><li><p>你也许注意到了，不管用双引号还是单引号都是正确的，Python 并不对它们进行区分。此外，<code>&#39;&#39;&#39;Hello world&#39;&#39;&#39;</code> 与 <code>&quot;&quot;&quot;Hello world&quot;&quot;&quot;</code> 也都是正确的（三引号）。当然，当你用 <strong>单引号</strong> 表示字符串时，字符串中间的 <code>&quot;</code> <strong>不用转义</strong>，反之亦然。当你用三引号时，均不需要转义，除非会使引号内容提前结束。</p></li><li><p>Python 的 <code>print</code> 默认会在末尾增加换行符，因此不用手动加 <code>\n</code>。</p></li></ol><h1 id="Chap-02-变量、类型、表达式"><a href="#Chap-02-变量、类型、表达式" class="headerlink" title="Chap.02 变量、类型、表达式"></a>Chap.02 变量、类型、表达式</h1><h2 id="Python，动态类型"><a href="#Python，动态类型" class="headerlink" title="Python，动态类型"></a>Python，动态类型</h2><p>众所周知，C 语言中，一个变量的“出生”必然伴随着类型的确定，并且死前不可更改（你在和我说强制类型转换？那算吗？），编译器需要知道要为它分配多少内存。但 Python 就不一样了，Python 变量的诞生并不需要指定类型，一条 <strong>赋值语句</strong> 就够了。请看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(a)<br>a = <span class="hljs-number">3.14159</span><br><span class="hljs-built_in">print</span>(a)<br>a = <span class="hljs-string">&quot;hello, pi&quot;</span><br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">3<br>3.14159<br>hello, pi<br></code></pre></td></tr></table></figure><p>在这个过程中，变量 <code>a</code> 先后经历了三种类型：<strong>整型</strong>（<code>int</code>，正常情况下不可能溢出），<strong>浮点数</strong>（<code>float</code>，没有 <code>double</code>），<strong>字符串</strong>（<code>str</code>，请记住，这不是 C 语言，这里的字符串就是字符串，不是什么“字符数组”），这说明了类型的可变。</p><p>同时，<code>print</code> 均接收了这些类型的变量，并正确地进行了处理，这说明，函数参数的类型也是可变的（你可以“约定”你的函数需要什么样类型的变量，但不是强制，除非手动进行检查）。</p><p>此外，Python 还有一种 <strong>布尔</strong> 类型，取值为 <code>True</code> 和 <code>False</code> 两种，表示逻辑“真”与“假”，如果它们参与 <strong>算术运算</strong>，则值为 <code>1</code> 与 <code>0</code>。</p><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>没啥，和 C 语言差不多，但是支持中文变量名（高版本的 C 语言编译器也支持），不建议使用下划线开头，除非你了解这样做的含义。Python 的保留字如下：</p><ul><li><code>def</code> <code>return</code> <code>None</code> <code>pass</code></li><li><code>if</code> <code>else</code> <code>elif</code></li><li><code>not</code> <code>and</code> <code>or</code> <code>is</code> <code>in</code> <code>True</code> <code>False</code></li><li><code>for</code> <code>while</code> <code>break</code> <code>continue</code></li><li><code>with</code> <code>as</code> <code>import</code> <code>from</code></li><li><code>class</code></li><li><code>try</code> <code>except</code> <code>finally</code> <code>raise</code></li><li><code>lambda</code> <code>global</code> <code>nonlocal</code></li><li><code>del</code> <code>yield</code> <code>assert</code></li></ul><p>它们是不能用作变量名的。这些不用记，一旦你写了，IDLE 会彩色显示，一目了然。</p><p>与 C 语言不同，你 <strong>可以</strong> 将 <code>print</code> 等函数用作变量名，因为它原来是 “函数类型” 的变量，Python 的类型是可变的。（但是不建议。）</p><h2 id="知识点小记（No-02）"><a href="#知识点小记（No-02）" class="headerlink" title="知识点小记（No. 02）"></a>知识点小记（No. 02）</h2><ol><li><p>Python 变量的定义不用标注类型，直接赋值即可。</p></li><li><p>Python 的类型可变，但是不建议变来变去，以免给自己挖坑。</p></li><li><p>常用的类型有：整型（<code>int</code>）、浮点型（<code>float</code>）、字符串类型（<code>str</code>）、布尔型（<code>bool</code>），还有后面的列表（<code>list, []</code>）、字典（<code>dict, &#123;&#125;</code>）、元组（<code>tuple, ()</code>），以及函数类型等等。</p></li></ol><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>把与 C 语言不一样的挑出来：</p><ul><li><p><code>/</code> 与 <code>//</code>：一个除号的，表示浮点除法，<code>3 / 2</code> 结果为 <code>1.5</code>；两个除号连在一起的，表示整除，<code>3 // 2 == 1</code>。如果浮点数参与运算，两者没有区别。</p></li><li><p><code>**</code>：两个连在一起的乘号，表示乘方，<code>2 ** 3 == 8</code></p></li></ul><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>使用 <code>and</code> <code>or</code> <code>not</code> 表示 “与”“或”“非”，字面意思，通俗易懂。比较两数不相等，可以使用 <code>A != B</code>，但更推荐使用 <code>not A == B</code>。</p><p>事实上，<code>and</code> 和 <code>or</code> 的处理会更加复杂，参见附录 <a href="#and-%E4%B8%8E-or-%E6%80%8E%E6%A0%B7%E8%AE%A1%E7%AE%97%EF%BC%9F">and 与 or 怎样计算？</a></p><h2 id="字符串运算（后续会单列一节）"><a href="#字符串运算（后续会单列一节）" class="headerlink" title="字符串运算（后续会单列一节）"></a>字符串运算（后续会单列一节）</h2><p>字符串可以相加，意为“拼接”，<code>&quot;Hello&quot; + &quot;World&quot; == &quot;HelloWorld&quot;</code>。</p><p>因此，可以使用 <code>+=</code> 来追加字符串的内容。</p><p>字符串可以与正整数相乘，意为“重复”，<code>&quot;A&quot; * 5 == &quot;AAAAA&quot;</code>。</p><p>关键字 <code>in</code> 可以判断字符串的包含关系，<code>(&quot;abc&quot; in &quot;abcdef&quot;) == True</code></p><p>可以直接使用 <code>&gt;=</code> <code>==</code> 等比较运算符比较两个字符串的字典序。</p><h2 id="知识点小记（No-03）"><a href="#知识点小记（No-03）" class="headerlink" title="知识点小记（No. 03）"></a>知识点小记（No. 03）</h2><ol><li><p>Python 将普通除法与整除分开了，这很好，乘方也有了自己的符号。</p></li><li><p>逻辑运算中，Python 使用通俗的单词代替了 <code>&amp;&amp;</code> <code>||</code> 等符号，更方便，但也许你需要适应一下，别忘了照顾一下优先级。</p></li><li><p>字符串可以相加，可以与正整数相乘，其他运算都是没有定义的。使用 <code>A in B</code> 可以判断 A 串是否在 B 串中。字符串的字典序可以直接比较。</p></li><li><p>此外，附录还介绍了 Python 的一个<a href="#if-else%E8%BF%90%E7%AE%97%E7%AC%A6">三目运算符</a>，可以去看一看。</p></li></ol><h1 id="Chap-03-函数的简单使用"><a href="#Chap-03-函数的简单使用" class="headerlink" title="Chap.03 函数的简单使用"></a>Chap.03 函数的简单使用</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>语法如下，注意 <strong>冒号</strong> 与缩进。参数表可以为空，参数和返回值都不标类型，可以没有 <code>return</code>，也可以只写 <code>return</code> 而不加返回值，后两者相当于 C 语言的 <code>void</code> 型的函数。<code>def</code> 是定义函数的关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">参数列表</span>):<br>    函数体<br>    <span class="hljs-keyword">return</span> 返回值<br></code></pre></td></tr></table></figure><p>例如下面的例子，计算球体体积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ball_volumn</span>(<span class="hljs-params">r</span>):<br>    pi = <span class="hljs-number">3.1415</span><br>    v = <span class="hljs-number">4</span> / <span class="hljs-number">3</span> * pi * (r ** <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><h2 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h2><p>事实上，你也可以给参数和返回值写上类型，但仅仅是“写上”，你乱写也没人管。类型标注是给 <strong>人</strong> 看的，给 <strong>代码编辑器</strong> 看的，即使你不写或者写上了错误的类型，运行时也不会出问题。改造一下上面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_ball_volumn</span>(<span class="hljs-params">r: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>    pi = <span class="hljs-number">3.1415</span><br>    v = <span class="hljs-number">4</span> / <span class="hljs-number">3</span> * pi * (r ** <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> v<br></code></pre></td></tr></table></figure><h1 id="Chap-04-条件判断与循环"><a href="#Chap-04-条件判断与循环" class="headerlink" title="Chap.04 条件判断与循环"></a>Chap.04 条件判断与循环</h1><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>使用的组合为 <code>if-elif-else</code>，其中，<code>elif</code> 是 <code>else if</code> 的意思，但不可以使用 <code>else if</code>。其具体语法如下，注意 <strong>冒号</strong> 与缩进。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> condition1:<br>    action1()<br><span class="hljs-keyword">elif</span> condition2:<br>    action2()<br><span class="hljs-keyword">elif</span> condition3:<br>    action3()<br><span class="hljs-keyword">else</span>:<br>    action4()<br></code></pre></td></tr></table></figure><p>同 C 语言一样，<code>elif</code> 可以有多个，也可以没有。<code>else</code> 置于最后，也可以没有。但是注意，与大括号表示范围不同，Python 使用 <strong>缩进</strong> 标记范围。每一层缩进推荐使用 <strong>4 个空格</strong>。同时，条件不用加小括号，条件后与 <code>else</code> 后跟有 <strong>英文冒号</strong>，可以理解为“开启下文”。</p><p>例如，重点关注并体会一下缩进的层数关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">isChinese = <span class="hljs-literal">True</span><br>age = <span class="hljs-number">19</span><br><span class="hljs-keyword">if</span> isChinese:<br>    <span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成年的中国公民&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未成年的中国公民&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;是外国人&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="小试牛刀（Ex-01-判断闰年）"><a href="#小试牛刀（Ex-01-判断闰年）" class="headerlink" title="小试牛刀（Ex. 01 判断闰年）"></a>小试牛刀（Ex. 01 判断闰年）</h3><p>新建一个文件，命名为 <code>LeapYear.py</code>，在其中写一个函数，签名为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">leap_year</span>(<span class="hljs-params">y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    ...<br></code></pre></td></tr></table></figure><p>用来判断传入的年份是否为闰年，返回 <code>True</code> 或 <code>False</code>。测试程序为 <code>test_leap.py</code>。</p><p><strong>具体而言，在 <code>IDLE</code> 中新建一个 python 文件，将代码文件保存在测试程序的同一个文件夹中，如下图所示。</strong></p><p><img src="/img/dmpython-test-file.png" alt="置于同一文件夹"></p><p><strong>双击运行测试程序，可以进行测试，如下图所示。测试不通过有几种情况，一个是文件、函数命名不正确；一个是返回值类型错误，比如，要求一个 <code>True</code>，结果返回了 <code>&quot;True&quot;</code>；一个是运行时错误（程序产生了异常，比如列表越界、未赋值引用）；一个是结果错误（测试程序会给出错误的输入、输出）。</strong></p><p><img src="/img/dmpython-test.png" alt="测试通过！"></p><p>注意，因为你的代码文件中只定义了函数，而 <strong>没有调用函数</strong>，所以运行代码程序 <strong>不会产生任何结果</strong>（除非报错），你可以自己增加一些函数调用，比如 <code>print(func(5))</code> 这样的，只要命名正确，不会影响测试。</p><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>没啥好说的，除了不用小括号、要加冒号、要注意缩进，其他与 C 语言一样，同样可以用 <code>break</code> 与 <code>continue</code> 进行跳转。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">100</span>:<br>    <span class="hljs-built_in">sum</span> += i<br>    i += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br></code></pre></td></tr></table></figure><p>这段代码可以计算 $1+2+\cdots+100$ 的结果。</p><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>Python 并不支持 C 语言那样的 for 循环，但是你可以使用更加强大、灵活的 <code>for-in</code> 组合。</p><h3 id="遍历整数"><a href="#遍历整数" class="headerlink" title="遍历整数"></a>遍历整数</h3><p>这三种写法都可以，可以根据需要选择合适的写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">15</span>):<br>    <span class="hljs-built_in">print</span>(i)  <span class="hljs-comment"># 会打印 0 ~ 14 的整数</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>):<br>    <span class="hljs-built_in">print</span>(i)  <span class="hljs-comment"># 会打印 10 ~ 14 的整数，也即，[10, 15)</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(i)  <span class="hljs-comment"># 会打印 10, 13, 16, 19，也即，[10, 22)，间隔为 3</span><br></code></pre></td></tr></table></figure><p>要注意，在循环体内部修改 <code>i</code> 的值并不会影响循环的过程。每一次循环，<code>i</code> 的值都会被更新为下一个。同时，<code>range</code> 里的参数当然可以是变量。</p><h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Hello&quot;</span>:<br>    <span class="hljs-built_in">print</span>(c)<br></code></pre></td></tr></table></figure><p>用法几乎是一样的，但是同样，如果在循环体内部修改 <code>c</code> 的值，并不会影响循环进程，也不会改变原有字符串。</p><h3 id="小试牛刀（Ex-02-判断素数）"><a href="#小试牛刀（Ex-02-判断素数）" class="headerlink" title="小试牛刀（Ex. 02 判断素数）"></a>小试牛刀（Ex. 02 判断素数）</h3><p>新建一个文件，命名为 <code>Prime.py</code>，在其中写一个函数，签名为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_prime</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    ...<br></code></pre></td></tr></table></figure><p>用来判断传入的正整数（<code>num &gt;= 2</code>）是否为素数，返回<code>True</code> 或 <code>False</code>。测试程序为 <code>test_prime.py</code>。不用考虑时间复杂度，不给你测时间，怎么方便怎么写。</p><h3 id="小试牛刀（Ex-03-计算阶乘）"><a href="#小试牛刀（Ex-03-计算阶乘）" class="headerlink" title="小试牛刀（Ex. 03 计算阶乘）"></a>小试牛刀（Ex. 03 计算阶乘）</h3><p>新建一个文件，命名为 <code>Factorial.py</code>，在其中写一个函数，签名为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    ...<br></code></pre></td></tr></table></figure><p>计算判断传入的正整数（<code>1 &lt;= n &lt;= 100</code>）的阶乘，返回计算结果。测试程序为 <code>test_factorial.py</code>。不用考虑整数的溢出问题。</p><h1 id="Chap-05-列表与列表的遍历"><a href="#Chap-05-列表与列表的遍历" class="headerlink" title="Chap.05 列表与列表的遍历"></a>Chap.05 列表与列表的遍历</h1><p>Python 的列表绝对 <strong>不要理解为</strong> C 语言中的“数组”，列表中的值可以是 <strong>任意不同类型</strong>，甚至是一个列表。列表中 <strong>可以有</strong> 重复的值。列表可以被赋值给一个变量。<code>print</code> 函数可以直接打印整个列表。</p><h2 id="定义一个列表"><a href="#定义一个列表" class="headerlink" title="定义一个列表"></a>定义一个列表</h2><p>列表用中括号表示，各个元素用逗号隔开。举例如下。其中，<code>list_3</code> 为空列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">list_1 = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<br>list_2 = [<span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-string">&#x27;efg&#x27;</span>, <span class="hljs-number">1234</span>, <span class="hljs-string">&#x27;1234&#x27;</span>, <span class="hljs-string">&#x27;efg&#x27;</span>]<br>list_3 = []<br>list_4 = [<span class="hljs-number">123</span>, [<span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>], <span class="hljs-string">&#x27;qwert&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="列表取值与元素修改"><a href="#列表取值与元素修改" class="headerlink" title="列表取值与元素修改"></a>列表取值与元素修改</h2><p>你可以用方括号，同 C 语言一样，如 <code>list_2[1]</code> 的值为 <code>&#39;efg&#39;</code>。此外，列表还有“切片”操作，为了简化教程内容，自行百度，暂时用不到。</p><p>同时，<code>list_2[1] = &#39;EFG&#39;</code> 可以修改指定的元素（当然不要求类型相同）。</p><h2 id="列表追加"><a href="#列表追加" class="headerlink" title="列表追加"></a>列表追加</h2><p>可以使用 <code>append</code> 和 <code>extend</code> 方法对列表进行追加，但区别是， <code>append</code> 是将需要追加的数据作为 <strong>值</strong> 放在列表末尾，而 <code>extend</code> 方法是将另一个 <strong>列表中</strong> 的所有值按顺序放到列表后面。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">list_0 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>list_1 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>]<br><br>list_0.append(<span class="hljs-number">8</span>)<br>list_1.append(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(list_0)<br><span class="hljs-built_in">print</span>(list_1)<br><br>list_0.extend(list_1)<br><span class="hljs-built_in">print</span>(list_0)<br><br>list_0.append(list_1)<br><span class="hljs-built_in">print</span>(list_0)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">[0, 1, 2, 3, 4, 5, 8]<br>[3, 4, 6, 1, 10]<br>[0, 1, 2, 3, 4, 5, 8, 3, 4, 6, 1, 10]<br>[0, 1, 2, 3, 4, 5, 8, 3, 4, 6, 1, 10, [3, 4, 6, 1, 10]]<br></code></pre></td></tr></table></figure><h2 id="列表运算"><a href="#列表运算" class="headerlink" title="列表运算"></a>列表运算</h2><p>列表支持加 <code>+</code> 和乘 <code>*</code> 这两种运算，<code>+</code> 表示将 <strong>两个列表</strong> 合并成一个新的列表，而 <code>*</code> 则作用于 <strong>列表和正整数</strong> 之间，表示将列表中的值重复若干遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">list_1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>list_2 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br><br>list_3 = list_1 + list_2<br>list_4 = list_2 * <span class="hljs-number">3</span><br>list_1 += list_1<br><br><span class="hljs-built_in">print</span>(list_3)<br><span class="hljs-built_in">print</span>(list_4)<br><span class="hljs-built_in">print</span>(list_1)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">[1, 2, 2, 1, 0, 0, 3, 5]<br>[0, 0, 3, 5, 0, 0, 3, 5, 0, 0, 3, 5]<br>[1, 2, 2, 1, 1, 2, 2, 1]<br></code></pre></td></tr></table></figure><h2 id="插入元素与删除元素"><a href="#插入元素与删除元素" class="headerlink" title="插入元素与删除元素"></a>插入元素与删除元素</h2><ul><li><p><code>l.insert(i, x)</code> 将元素 <code>x</code> 插入到列表 <code>l</code> 的索引为 <code>i</code> 的位置，后面的元素依次后移。</p></li><li><p><code>l.pop(i)</code> <strong>返回</strong> 列表 <code>l</code> 中索引为 <code>i</code> 的元素，并将其删除。</p></li><li><p><code>l.remove(x)</code> 直接删除列表 <code>l</code> 中第一个值为 <code>x</code> 的元素。</p></li><li><p><code>l.clear()</code> 清除列表 <code>l</code> 中的所有元素。</p></li><li><p><code>del l[i]</code> 删除列表 <code>l</code> 中下标为 <code>[i]</code> 的元素，<code>del</code> 是一个新的关键字。</p></li></ul><h2 id="遍历列表中的元素"><a href="#遍历列表中的元素" class="headerlink" title="遍历列表中的元素"></a>遍历列表中的元素</h2><p>你也许猜到了，使用 <code>for-in</code> 循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-string">&#x27;asd&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-number">890</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> lst:<br>    <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">asd<br>123<br>890<br>[0, 1, 2]<br></code></pre></td></tr></table></figure><p>值得注意的是，列表中的列表并没有被“拆散”，也就是说，多维列表可以用多重循环遍历。</p><h2 id="小试牛刀（Ex-04-奇偶判断）"><a href="#小试牛刀（Ex-04-奇偶判断）" class="headerlink" title="小试牛刀（Ex.04 奇偶判断）"></a>小试牛刀（Ex.04 奇偶判断）</h2><p>新建一个文件，命名为 <code>JudgeOdd.py</code>，在其中写一个函数，签名为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">judge_odd</span>(<span class="hljs-params">lst: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">bool</span>]:<br>    ...<br><span class="hljs-comment"># list[int] 表示由 int 变量构成的列表</span><br></code></pre></td></tr></table></figure><p>判断给定列表中的每个正整数是否为奇数，返回另一个一一对应的列表。例如，传入 <code>[1, 2, 3]</code>，应该返回 <code>[True, False, True]</code>。测试程序为 <code>test_judge_odd.py</code>。</p><h2 id="小试牛刀（Ex-05-列表求和）"><a href="#小试牛刀（Ex-05-列表求和）" class="headerlink" title="小试牛刀（Ex.05 列表求和）"></a>小试牛刀（Ex.05 列表求和）</h2><p>新建一个文件，命名为 <code>ListSum.py</code>，在其中写一个函数，签名为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_sum</span>(<span class="hljs-params">lst: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    ...<br></code></pre></td></tr></table></figure><p>传入的为一个二维列表，保证其中不出现空列表，对于每个内层列表，计算其元素和，并将结果一一对应地放在一个新的列表中，返回。例如，传入 <code>[[1, 2], [3], [3, 0, 5]]</code>，应该返回 <code>[3, 3, 8]</code>。测试程序为 <code>test_list_sum.py</code>。</p><h1 id="Chap-06-拯救离散作业的杀器：eval-函数"><a href="#Chap-06-拯救离散作业的杀器：eval-函数" class="headerlink" title="Chap.06 拯救离散作业的杀器：eval 函数"></a>Chap.06 拯救离散作业的杀器：<code>eval</code> 函数</h1><p>简单来说，<code>eval</code> 函数可以计算 <strong>字符串</strong> 的结果，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;3 + 5&quot;</span><br>a = <span class="hljs-built_in">eval</span>(s)<br></code></pre></td></tr></table></figure><p>那么 <code>a</code> 的值就是 8，你也可以直接 <code>print(eval(s))</code> 将结果打印出来。</p><p>如果我们先前有定义变量，那么 <code>eval</code> 是可以读取变量的，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">3</span><br>b = <span class="hljs-number">5</span><br>s = <span class="hljs-string">&quot;a + a * b&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">eval</span>(s))<br></code></pre></td></tr></table></figure><h2 id="小试牛刀（Ex-06-计算结果）"><a href="#小试牛刀（Ex-06-计算结果）" class="headerlink" title="小试牛刀（Ex.06 计算结果）"></a>小试牛刀（Ex.06 计算结果）</h2><p>新建一个文件，命名为 <code>Calculator.py</code>，在其中写一个函数，签名为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    ...<br></code></pre></td></tr></table></figure><p>用来计算传入算式的值，表达式中至多出现三个变量，它们的名称与取值如下：<code>a = 1, b = 3, c = 10</code>。要求将这三个值代入算式并计算结果。测试数据保证为整数运算。测试程序为 <code>test_calc.py</code>。</p><h1 id="Chap-07-真值运算、真值表"><a href="#Chap-07-真值运算、真值表" class="headerlink" title="Chap.07 真值运算、真值表"></a>Chap.07 真值运算、真值表</h1><h2 id="从合式公式到-Python-代码"><a href="#从合式公式到-Python-代码" class="headerlink" title="从合式公式到 Python 代码"></a>从合式公式到 Python 代码</h2><p>现在我们可以思考一下合式公式与 Python 式子的对应关系。</p><p>首先是常元，可以使用 <code>1</code> 和 <code>0</code>，也可以使用 <code>True</code> 和 <code>False</code>。而变元，则可以用变量代替。</p><p>然后考虑联结词，“合取” 就是 <code>and</code>，“析取” 就是 <code>or</code>，“非” 则是 <code>not</code>。“蕴含” 与 “互蕴含” 可能复杂一些，但也不是不能讨论。</p><table><thead><tr><th align="center">$p$</th><th align="center">$q$</th><th align="center">$p \rightarrow q$</th><th align="center">$p \leftrightarrow q$</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>注意观察这个真值表，我们发现，$p \rightarrow q$ 的真值情况与 $p \leqslant q$ 竟然一致！而 $p \leftrightarrow q$ 则与 $p &#x3D; q$ 一致，也就是说，我们可以进行类似的替换，以达到合式公式在 Python 中进行计算的目的。</p><p>但是，请注意，<strong>运算的优先级不一样</strong>，在 Python 中，<strong>比较运算符的优先级高于与或非</strong>，但在数理逻辑中，蕴含、互蕴含的优先级应该是较低的，所以直接的替换是不正确的，应该多多加上小括号。</p><h2 id="通过-eval-计算真值赋值结果"><a href="#通过-eval-计算真值赋值结果" class="headerlink" title="通过 eval 计算真值赋值结果"></a>通过 <code>eval</code> 计算真值赋值结果</h2><p>可以先定义一个公式，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;(p &lt;= q) &lt;= ( (p &lt;= (not q)) &lt;= p )&quot;</span><br></code></pre></td></tr></table></figure><p>其中，已经将蕴含联结词进行了转换。<strong>请注意，应该尽可能加上小括号，否则可能会有语法错误。比如 <code>p &lt;= not q</code> 的优先级与结合性产生了矛盾，是一个不符合语法的式子</strong></p><p>接着，给变元 <code>p</code> 和 <code>q</code> 赋值，并计算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">p = <span class="hljs-literal">True</span><br>q = <span class="hljs-literal">False</span><br>result = <span class="hljs-built_in">eval</span>(s)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>结果为 <code>True</code>。</p><h2 id="打印真值表"><a href="#打印真值表" class="headerlink" title="打印真值表"></a>打印真值表</h2><p>要想打印真值表，肯定要能够遍历 <code>p</code> 和 <code>q</code> 的取值，可以使用多层 <code>for</code> 循环进行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> [<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]:<br>    <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> [<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]:<br>        result = <span class="hljs-built_in">eval</span>(s)<br>        <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>而要想打印一张“表”，就要学会 <code>print</code> 的一些灵活的使用方法。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(p, q, result)<br></code></pre></td></tr></table></figure><p>将多个变量或者常量用逗号隔开，<code>print</code> 会将它们打印在一行中，并默认使用 <strong>空格</strong> 隔开。通过指定 <code>sep</code> 参数，可以调整间隔符。如：<code>print(a, b, c, sep=&#39;\t&#39;)</code>，可以用制表符进行间隔。注意，这是一种新的语法，通过指定名称、值进行的参数传递一定要放在参数列表的末尾。</p><p>于是，就可以这样操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, s, sep=<span class="hljs-string">&#x27;\t&#x27;</span>)  <span class="hljs-comment"># 打印表头</span><br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> [<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]:<br>    <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> [<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]:<br>        result = <span class="hljs-built_in">eval</span>(s)<br>        <span class="hljs-built_in">print</span>(p, q, result, sep=<span class="hljs-string">&#x27;\t&#x27;</span>)<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">p       q       (p &lt;= q) &lt;= ( (p &lt;= (not q)) &lt;= p )<br>False   False   False<br>False   True    False<br>True    False   True<br>True    True    True<br></code></pre></td></tr></table></figure><p>如果将真值常元变为 <code>[0, 1]</code>，结果也是一样的，不过会以 <code>0</code> 和 <code>1</code> 的形式呈现。但是，<code>result</code> 可能仍然是 <code>True</code> 或 <code>False</code> 的形式，你可以通过 <code>int(result)</code> 获取其整数值。</p><h2 id="小试牛刀（Ex-07-可满足式（作业））"><a href="#小试牛刀（Ex-07-可满足式（作业））" class="headerlink" title="小试牛刀（Ex.07 可满足式（作业））"></a>小试牛刀（Ex.07 可满足式（作业））</h2><p>（如果看到这里，并且把上面的题目都 AC 了，但是这个作业还是不会做，可以私戳我寻求帮助。一定是教程哪里没有写明白或者讲清楚。又或者，想一想什么是“永真式”？）</p><p>新建一个文件，命名为 <code>Satisfiable.py</code>，在其中写一个函数，签名为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    ...<br></code></pre></td></tr></table></figure><p><img src="/img/work-satisfy.png" alt="作业题干"></p><p>题干见离散数学第二次作业。测试程序为 <code>test_satisfiable.py</code>，我提供了 10 组测试数据，仅供参考。此题不提供例程。</p><h2 id="小试牛刀（Ex-08-析取式数（作业））"><a href="#小试牛刀（Ex-08-析取式数（作业））" class="headerlink" title="小试牛刀（Ex.08 析取式数（作业））"></a>小试牛刀（Ex.08 析取式数（作业））</h2><p>这个题目需要计算所给式子中出现变元的种数，因为主合取范式中析取式的个数与 $2^n$ 有关。我感觉有 <strong>两种思路</strong>：</p><p>一个是不管出现哪些变元，均对 $P,Q,R$ 全部遍历，统计其中满足所给公式的数目，然后除以相应的数目，比如，若公式没有出现 $R$，则当 $R$ 取真、假两种时，结果是一样的，这样就重复算了两边。</p><p>另一种思路，可能需要写一些复杂的代码，就是判断出现了 <strong>哪些</strong> 变元，然后直接给他们赋值，可以使用 <code>itertools</code> 库（快来看我的另一篇<a href="/2023/03/30/Python-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%BA%93%E2%80%94%E2%80%94%E8%AE%A9%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E6%9B%B4%E5%8A%A0%E4%BC%98%E9%9B%85/">博客</a>），也可以使用二进制数码的方式。</p><p>新建一个文件，命名为 <code>Disconjunctive.py</code>，在其中写一个函数，签名为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">terms</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    ...<br></code></pre></td></tr></table></figure><p><img src="/img/work-disconjunctive.png" alt="作业题干"></p><p>题干见离散数学第三次作业。测试程序为 <code>test_disconjunctive.py</code>，我提供了 12 组测试数据，仅供参考。此题不提供例程。因为这个东西我也不是很会，可能数据点有问题？请及时与我分享你的想法。</p><h1 id="Chap-EX-练习解答"><a href="#Chap-EX-练习解答" class="headerlink" title="Chap.EX 练习解答"></a>Chap.EX 练习解答</h1><h2 id="01-判断闰年"><a href="#01-判断闰年" class="headerlink" title="01 判断闰年"></a>01 判断闰年</h2><p>此题在于掌握 Python 的缩进。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">leap_year</span>(<span class="hljs-params">y: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">if</span> y % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:      <span class="hljs-comment"># 对百年进行特判</span><br>        <span class="hljs-keyword">if</span> y % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>   <span class="hljs-comment"># 需要是 400 的倍数</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">elif</span> y % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>:      <span class="hljs-comment"># 不是整百年份，是 4 的倍数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="02-判断素数"><a href="#02-判断素数" class="headerlink" title="02 判断素数"></a>02 判断素数</h2><p>此题在于使用 <code>for</code> 循环与 <code>range</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_prime</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, num):  <span class="hljs-comment"># 遍历 2, 3, ..., num - 1</span><br>        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="03-计算阶乘"><a href="#03-计算阶乘" class="headerlink" title="03 计算阶乘"></a>03 计算阶乘</h2><p>此题在于使用 <code>while</code> 循环，并且熟练掌握定义临时变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    res = <span class="hljs-number">1</span><br>    i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> i &lt;= n:  <span class="hljs-comment"># 当然用 for 循环也可以</span><br>        res *= i<br>        i += <span class="hljs-number">1</span>     <span class="hljs-comment"># 对了，没有 i++ 这种写法</span><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="04-奇偶判断"><a href="#04-奇偶判断" class="headerlink" title="04 奇偶判断"></a>04 奇偶判断</h2><p>此题在于练习列表的遍历以及从空开始扩充列表的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">judge_odd</span>(<span class="hljs-params">lst: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">bool</span>]:<br>    res = []                   <span class="hljs-comment"># 创建了一个空的列表</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> lst:            <span class="hljs-comment"># 遍历列表，遍历一个扩充一个</span><br>        <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            res.append(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">else</span>:<br>            res.append(<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>循环体内可以简写为 <code>res.append(num % 2 != 0)</code>，注意，<code> != 0</code> 是必要的，不然就是 <code>int</code>，而不是 <code>bool</code> 了。</p><h2 id="05-列表求和"><a href="#05-列表求和" class="headerlink" title="05 列表求和"></a>05 列表求和</h2><p>此题在于练习遍历多维列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">list_sum</span>(<span class="hljs-params">lst: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    res = []<br>    <span class="hljs-keyword">for</span> sub_lst <span class="hljs-keyword">in</span> lst:       <span class="hljs-comment"># sub_lst 依然是列表</span><br>        sub_sum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> sub_lst:   <span class="hljs-comment"># 正常的列表求和过程</span><br>            sub_sum += num<br>        res.append(sub_sum)<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="06-计算结果"><a href="#06-计算结果" class="headerlink" title="06 计算结果"></a>06 计算结果</h2><p>此题在于练习 <code>eval</code> 的用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    a = <span class="hljs-number">1</span><br>    b = <span class="hljs-number">3</span><br>    c = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(s)<br></code></pre></td></tr></table></figure><h1 id="Chap-XX-附录"><a href="#Chap-XX-附录" class="headerlink" title="Chap.XX 附录"></a>Chap.XX 附录</h1><h2 id="第一份的代码与注释"><a href="#第一份的代码与注释" class="headerlink" title="第一份的代码与注释"></a>第一份的代码与注释</h2><p><a href="#%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">单击此处跳转回去</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os  <span class="hljs-comment"># 导入 os 包，os 即 operating system 的缩写</span><br><br>subjects = [<span class="hljs-string">&#x27;语文&#x27;</span>, <span class="hljs-string">&#x27;数学&#x27;</span>, <span class="hljs-string">&#x27;英语&#x27;</span>, <span class="hljs-string">&#x27;物理&#x27;</span>, <span class="hljs-string">&#x27;化学&#x27;</span>, <span class="hljs-string">&#x27;生物&#x27;</span>]<br><span class="hljs-comment"># 定义一个名为 subjects 的列表，有如上这些值</span><br><br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;地理&#x27;</span> <span class="hljs-keyword">in</span> subjects:  <span class="hljs-comment"># 如果 ‘地理’ 在 subjects 中，冒号可以理解为开启下文</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我们要学地理&#x27;</span>)  <span class="hljs-comment"># 则打印这一句话</span><br><span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我们不要学地理&#x27;</span>)  <span class="hljs-comment"># 则打印这一句话</span><br><br>sub = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;你要学什么？&#x27;</span>)  <span class="hljs-comment"># 定义 sub 变量，并获取 input，即用户输入</span><br><span class="hljs-keyword">if</span> sub <span class="hljs-keyword">in</span> subjects:  <span class="hljs-comment"># 和上面一样的道理，如果 sub 在 subjects 中</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我们要学<span class="hljs-subst">&#123;sub&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 则打印这一句话，sub 可以替换为上面输入的内容</span><br><span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我们不要学<span class="hljs-subst">&#123;sub&#125;</span>&#x27;</span>)  <span class="hljs-comment"># 则打印这一句话</span><br><br>os.system(<span class="hljs-string">&#x27;pause&#x27;</span>)  <span class="hljs-comment"># 利用 os 包中的 system 函数，调用系统命令，pause 是暂停的意思</span><br></code></pre></td></tr></table></figure><h2 id="and-与-or-怎样计算？"><a href="#and-与-or-怎样计算？" class="headerlink" title="and 与 or 怎样计算？"></a><code>and</code> 与 <code>or</code> 怎样计算？</h2><p><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97">单击此处跳转回去</a></p><p>先来看一看官方文档上是怎么介绍这两个运算的：<br><img src="/img/a1-01.png" alt="官方文档的介绍"></p><p>只有在一定的情况下，后面的式子才会被计算，我们分别来看一下。</p><h3 id="and-的短路运算"><a href="#and-的短路运算" class="headerlink" title="and 的短路运算"></a>and 的短路运算</h3><p><code>x and y</code>：只有当 <code>x</code> 是 <code>True</code> 时才会计算 <code>y</code>，当 <code>x</code> 是 <code>False</code> 时不会计算 <code>y</code> 的值。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getY</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;y 被 <span class="hljs-subst">&#123;s&#125;</span> 计算了！&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-number">1</span>+<span class="hljs-number">2</span>==<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> getY(<span class="hljs-string">&#x27;part.1&#x27;</span>)==<span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;part.1&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-number">1</span>+<span class="hljs-number">2</span>==<span class="hljs-number">4</span> <span class="hljs-keyword">and</span> getY(<span class="hljs-string">&#x27;part.2&#x27;</span>)==<span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;part.2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">y 被 part.1 计算了！<br>part.1<br></code></pre></td></tr></table></figure><p>只有在 <code>part.1</code> 中，<code>getY()</code> 才会被计算。</p><h3 id="or-的短路运算"><a href="#or-的短路运算" class="headerlink" title="or 的短路运算"></a>or 的短路运算</h3><p><code>x or y</code>：只有当 <code>x</code> 是 <code>False</code> 时才会计算 <code>y</code>，当 <code>x</code> 是 <code>True</code> 时不会计算 <code>y</code> 的值。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getY</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;y 被 <span class="hljs-subst">&#123;s&#125;</span> 计算了！&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-number">1</span>+<span class="hljs-number">2</span>==<span class="hljs-number">3</span> <span class="hljs-keyword">or</span> getY(<span class="hljs-string">&#x27;part.1&#x27;</span>)==<span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;part.1&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-number">1</span>+<span class="hljs-number">2</span>==<span class="hljs-number">4</span> <span class="hljs-keyword">or</span> getY(<span class="hljs-string">&#x27;part.2&#x27;</span>)==<span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;part.2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">part.1<br>y 被 part.2 计算了！<br>part.2<br></code></pre></td></tr></table></figure><p>只有在 <code>part.2</code> 中，<code>getY()</code> 才会被计算。</p><h3 id="实际取值"><a href="#实际取值" class="headerlink" title="实际取值"></a>实际取值</h3><p>事实上，<code>and</code> 和 <code>or</code> 返回的并不一定是布尔值，而是 <code>x</code> 或 <code>y</code> 的具体取值。只是在判断时（比如 <code>if</code> 或 <code>while</code> 语句中），会被自动转化成布尔值。<code>0</code> 或者空列表，空字典，空字符串会被转化成 <code>False</code>。而在不用进行判断的情况，这个值会被保留。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;321&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;abc&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">321<br>abc<br></code></pre></td></tr></table></figure><p>在第一行中，<code>&#39;123&#39;</code> 是 <code>True</code>，所以这个 <code>and</code> 会返回第二个操作数的值，即 <code>&#39;321&#39;</code> 会被打印。</p><h2 id="if-else运算符"><a href="#if-else运算符" class="headerlink" title="if-else运算符"></a>if-else运算符</h2><p><a href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E8%AE%B0%EF%BC%88No-03%EF%BC%89">单击此处跳转回去</a></p><p>在 <code>C/C++</code> 中，有一种三目运算符：<code>x ?  y : z</code>，若 <code>x</code> 为真，则取 <code>y</code> 的值，否则则取 <code>z</code> 的值。在 Python 中也有类似的语法。</p><p>因为其与 <code>if-else</code> 语句意义相似，在 Python 中使用 <code>if</code> 和 <code>else</code> 来表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">num1 = (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-number">1</span>+<span class="hljs-number">2</span>==<span class="hljs-number">3</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span>)<br>num2 = (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-number">1</span>+<span class="hljs-number">2</span>==<span class="hljs-number">4</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(num1)<br><span class="hljs-built_in">print</span>(num2)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1<br>2<br></code></pre></td></tr></table></figure><p>理解起来很简单，但是可能有些倒装：<code>x if y else z</code>。值取 <code>x</code>，如果 <code>y</code> 为真；否则取 <code>z</code>。</p><p>注意，这个并不是传统的 <code>if-else</code> 语句，这里的 <code>else</code> 不可以省略。</p><hr><p>致谢：<a href="https://albertling0.github.io/">小飞机</a></p>]]></content>
    
    
    <categories>
      
      <category>Python 教程</category>
      
      <category>入门教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt6 技术难点笔记</title>
    <link href="/2023/03/18/PyQt6-%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/18/PyQt6-%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>此文仅作记录，其内容均在实际项目中得到验证，但仍不保证其正确性与合理性。</p></blockquote><h1 id="只显示窗口而不出现控制台"><a href="#只显示窗口而不出现控制台" class="headerlink" title="只显示窗口而不出现控制台"></a>只显示窗口而不出现控制台</h1><ul><li><p>直接运行：将主程序的拓展名改为 <code>.pyw</code></p></li><li><p>打包运行：pyinstaller 的命令中添加 <code>-w</code> 参数</p></li></ul><h1 id="让程序的异常信息能够正常显示"><a href="#让程序的异常信息能够正常显示" class="headerlink" title="让程序的异常信息能够正常显示"></a>让程序的异常信息能够正常显示</h1><p>通常在 PyCharm 中运行，程序遇到异常并退出，有时候无法显示该异常的 <code>traceback</code>，可以通过自定义 <code>sys.excepthook</code>，让程序用我们规定的方式处理未被捕获的异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> traceback <span class="hljs-keyword">as</span> tb<br><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QApplication, QMessageBox<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exception_hook</span>(<span class="hljs-params">exctype, value, traceback</span>):<br>    s = <span class="hljs-string">&quot;\n&quot;</span>.join(tb.format_exception(exctype, value, traceback))<br>    QMessageBox.critical(<span class="hljs-literal">None</span>, <span class="hljs-string">&quot;程序抛出异常&quot;</span>, s)<br>    sys.exit(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app = QApplication(sys.argv)<br>    sys.excepthook = exception_hook<br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="/img/pyqt-exception-hook.png" alt="未处理的异常被显示在对话框中"></p><p>弹出对话框，不仅可以让我们有反应的余地，也能让用户能更好地反馈问题。但要注意，因为使用了 <code>QMessageBox</code>，需要先来一个 <code>QApplication</code>，不然无法正常显示。</p><h1 id="在-QMainWindow-的下方显示状态信息"><a href="#在-QMainWindow-的下方显示状态信息" class="headerlink" title="在 QMainWindow 的下方显示状态信息"></a>在 QMainWindow 的下方显示状态信息</h1><p>使用 <code>self.statusBar()</code> 可以获取该窗口的状态栏，类型为 <code>QStatusBar</code>，其常用方法有：</p><ul><li><p><code>ShowMessage(self, p_str: str, msecs=0)</code>，在状态栏的左下角中显示信息，持续 <code>msec</code> 毫秒，若 <code>msec</code> 为 0，则信息会一直存在，直到 <code>clearMessage()</code> 被调用，或者新的信息被展示。</p></li><li><p><code>clearMessage(self)</code> 清除当前的 message。</p></li><li><p><code>currentMessage(self)</code> 获取当前的消息，返回 str 类型。</p></li><li><p><code>addPermanentWidget(self, widget: QWidget, stretch=0)</code> 向状态栏中添加一个 widget，显示在右下角，不会被上述的 message 覆盖。 stretch 参数是被用来计算合适的大小的，默认情况是适合该 widget 的最小尺寸<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="The stretch parameter is used to compute a suitable size for the given widget as the status bar grows and shrinks. The default stretch factor is 0, i.e giving the widget a minimum of space.">[1]</span></a></sup>。</p></li></ul><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QMainWindow</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.statusBar().addPermanentWidget(QLabel(<span class="hljs-string">&quot;永久信息&quot;</span>, self))<br>        self.statusBar().showMessage(<span class="hljs-string">&quot;5 秒消失&quot;</span>, <span class="hljs-number">5000</span>)<br>        self.show()<br></code></pre></td></tr></table></figure><p>当创建 <code>MyWindow</code> 对象时，会有如下窗口，5 秒钟后，左侧的信息消失。</p><p><img src="/img/pyqt-status.png" alt="StatusBar 实例"></p><h1 id="使-QTextEdit-的背景透明"><a href="#使-QTextEdit-的背景透明" class="headerlink" title="使 QTextEdit 的背景透明"></a>使 QTextEdit 的背景透明</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt6.QtGui <span class="hljs-keyword">import</span> QPalette, QColor, QBrush<br><br>palette = self.palette()<br>palette.setBrush(QPalette.ColorRole.Base, QBrush(QColor(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)))<br>self.setPalette(palette)<br></code></pre></td></tr></table></figure><p>其中，<code>self</code> 为 <code>QTextEdit</code> 或其子类的对象；<code>QColor</code> 的四个参数分别为 r、g、b、a，取值为 0-255 的整数值。</p><h1 id="设置-widget-的背景色、字体色"><a href="#设置-widget-的背景色、字体色" class="headerlink" title="设置 widget 的背景色、字体色"></a>设置 widget 的背景色、字体色</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">self.setAutoFillBackground(<span class="hljs-literal">True</span>)<br>palette = self.palette()<br>palette.setColor(self.backgroundRole(), background_color)<br>palette.setColor(self.foregroundRole(), text_color)<br>self.setPalette(palette)<br></code></pre></td></tr></table></figure><p>其中，<code>self</code> 为 <code>QPaintDevice</code> 子类的对象；<code>background_color</code> 为待设置的背景色，<code>QColor</code> 类型；<code>text_color</code> 为待设置的文字颜色。</p><p>而使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">old_background_color = palette.color(self.backgroundRole())<br></code></pre></td></tr></table></figure><p>可以获取之前的 <code>QColor</code> 类型的颜色。</p><h1 id="捕获按键信息"><a href="#捕获按键信息" class="headerlink" title="捕获按键信息"></a>捕获按键信息</h1><p>需要重写类的 <code>keyPressEvent</code> 事件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt6.QtGui <span class="hljs-keyword">import</span> QKeyEvent<br><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QWidget,<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> Qt<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QMainWindow</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">keyPressEvent</span>(<span class="hljs-params">self, a0: QKeyEvent</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> a0.isAutoRepeat():<br>            <span class="hljs-keyword">return</span><br>        key = a0.key()<br>        <span class="hljs-keyword">if</span> key == Qt.Key.Key_Z:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;按下 Z 键&quot;</span>)<br>        <span class="hljs-keyword">if</span> key == Qt.Key.Key_X:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;按下 X 键&quot;</span>)<br>        ...<br></code></pre></td></tr></table></figure><p>其中，<code>a0.isAutoRepeat()</code> 是用来检测是否为长按导致的事件，若是则不进行处理。</p><p>对于组合键，可以使用 <code>a0.modifiers()</code> 获取，其类型为 <code>Qt.KeyboardModifier</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">keyPressEvent</span>(<span class="hljs-params">self, a0: QKeyEvent</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> a0.isAutoRepeat():<br>        <span class="hljs-keyword">return</span><br>    ctrl_alt = Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.AltModifier<br>    key = a0.key()<br>    modifiers = a0.modifiers()<br>    <span class="hljs-keyword">if</span> modifiers == ctrl_alt <span class="hljs-keyword">and</span> key == Qt.Key.Key_A:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;按下了 Ctrl + Alt + A 组合键&quot;</span>)<br></code></pre></td></tr></table></figure><p>若要区分按下字母的大小写，可以使用 <code>a0.text()</code> 获取，类型为 <code>str</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">keyPressEvent</span>(<span class="hljs-params">self, a0: QKeyEvent</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> a0.isAutoRepeat():<br>        <span class="hljs-keyword">return</span><br>    txt = a0.text()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;按下了 &lt;<span class="hljs-subst">&#123;txt&#125;</span>&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p>注意，按下 shift 或者 capslock 都会触发这个事件：</p><p><img src="/img/pyqt-key-text.png" alt="text() 会得到很多空字符串"></p><h1 id="使-QLineEdit-支持文件拖拽"><a href="#使-QLineEdit-支持文件拖拽" class="headerlink" title="使 QLineEdit 支持文件拖拽"></a>使 QLineEdit 支持文件拖拽</h1><p>需要继承 <code>QLineEdit</code> 类，并重写其中的若干方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DragLineEdit</span>(<span class="hljs-title class_ inherited__">QLineEdit</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent=...</span>):<br>        <span class="hljs-built_in">super</span>(DragLineEdit, self).__init__(parent)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dragEnterEvent</span>(<span class="hljs-params">self, a0: QtGui.QDragEnterEvent</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> a0.mimeData().hasUrls():<br>            a0.acceptProposedAction()<br>        <span class="hljs-keyword">else</span>:<br>            a0.ignore()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dragMoveEvent</span>(<span class="hljs-params">self, e: QtGui.QDragMoveEvent</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dropEvent</span>(<span class="hljs-params">self, a0: QtGui.QDropEvent</span>) -&gt; <span class="hljs-literal">None</span>:<br>        mime_data = a0.mimeData()<br>        <span class="hljs-keyword">if</span> mime_data.hasUrls():<br>            urls = mime_data.urls()<br>            file_name = urls[<span class="hljs-number">0</span>].toLocalFile()<br>            self.setText(file_name)<br>            a0.accept()<br>        <span class="hljs-keyword">else</span>:<br>            a0.ignore()<br></code></pre></td></tr></table></figure><p>这里着重了解一下事件的 <code>accept()</code> 与 <code>ignore()</code> 方法，当”接受“一个事件时，相关的动作会被采取。在 <code>dragEnterEvent</code> 事件中，当拖拽过来的东西中含有 url （包括网址、文件）时，会显示如图所示的提示，否则则不会有显示。</p><p><img src="/img/pyqt-drag.png" alt="拖拽文件的提示"></p><p>当用户在输入框中松开鼠标时，会触发 <code>dropEvent</code> 事件，该事件同样进行了判断，并获取了本地文件的路径。</p><h1 id="多线程的坑"><a href="#多线程的坑" class="headerlink" title="多线程的坑"></a>多线程的坑</h1><ul><li><p>QMessageBox 在子线程中被调用会出问题。</p></li><li><p>让子线程一直运行，然后通过信号发布任务，似乎是一个很不好的想法。为什么不让子线程启动的时候就开始执行任务，弄好就关闭呢？</p></li></ul><h1 id="简单动画"><a href="#简单动画" class="headerlink" title="简单动画"></a>简单动画</h1><p>首先需要继承一个控件，创建一个需要进行动画补间的 <code>pyqtProperty</code>，并设置其 setter（即其中的 <code>fset</code> 参数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QLabel<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> pyqtProperty<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ColoredLabel</span>(<span class="hljs-title class_ inherited__">QLabel</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_set_background_color</span>(<span class="hljs-params">self, background_color: QColor</span>):<br>        self.setAutoFillBackground(<span class="hljs-literal">True</span>)<br>        palette = self.palette()<br>        palette.setColor(self.backgroundRole(), background_color)<br>        self.setPalette(palette)<br><br>    color_anim = pyqtProperty(QColor, fset=_set_background_color)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent</span>):<br>        <span class="hljs-built_in">super</span>().__init__(<span class="hljs-string">&quot;Hello world&quot;</span>, parent)<br>        self.setGeometry(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>接着，在主窗口类中创建一个 <code>QPropertyAnimation</code> 对象，设置要操作的控件，以及属性名。调用 <code>setDuration</code> 方法，设置动画持续的时间（毫秒），调用 <code>setStartValue</code> 和 <code>setEndValue</code> 方法设置始末状态，最后通过 <code>start</code> 方法开始动画。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QMainWindow, QPushButton<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> QPropertyAnimation<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(<span class="hljs-title class_ inherited__">QMainWindow</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.label = ColoredLabel(self)<br><br>        self.main_anim = QPropertyAnimation(self.label, <span class="hljs-string">b&quot;color_anim&quot;</span>)<br>        self.main_anim.setDuration(<span class="hljs-number">3000</span>)<br>        self.main_anim.setStartValue(QColor(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br>        self.main_anim.setEndValue(QColor(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br><br>        self.button = QPushButton(<span class="hljs-string">&quot;开始动画&quot;</span>, self)<br>        self.button.clicked.connect(self.main_anim.start)<br><br>        self.show()<br></code></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="/img/pyqt-anim.jpg" alt="颜色渐变动画"></p><h1 id="文件对话框"><a href="#文件对话框" class="headerlink" title="文件对话框"></a>文件对话框</h1><p>调用 <code>getOpenFileUrl</code> 方法，返回 <code>tuple[QUrl, str]</code> 类型，可以限制打开文件的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PyQt6.QtWidgets <span class="hljs-keyword">import</span> QFileDialog<br><span class="hljs-keyword">from</span> PyQt6.QtCore <span class="hljs-keyword">import</span> QUrl<br><br>url = QFileDialog.getOpenFileUrl(<br>    self, <span class="hljs-string">&quot;选择打开的文件&quot;</span>,<br>    QUrl.fromLocalFile(<span class="hljs-string">&quot;./&quot;</span>), <span class="hljs-string">&quot;(*.txt)&quot;</span><br>)[<span class="hljs-number">0</span>].path()[<span class="hljs-number">1</span>:]<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(url):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;invalid url: &lt;<span class="hljs-subst">&#123;url&#125;</span>&gt;&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(url)<br></code></pre></td></tr></table></figure><p>其中，<code>&quot;选择打开的文件&quot;</code> 为对话框的标题，<code>QUrl.fromLocalFile(&quot;./&quot;)</code> 指定了默认的位置，而 <code>&quot;(*.txt)&quot;</code> 限定了文件的类型。</p><p><img src="/img/pyqt-choose-file.png" alt="文件对话框"></p><p>注意，如果点击”取消“按钮，将会得到一个空的 url，需要格外留心。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>The stretch parameter is used to compute a suitable size for the given widget as the status bar grows and shrinks. The default stretch factor is 0, i.e giving the widget a minimum of space.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Python 教程</category>
      
      <category>实用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码笔记</tag>
      
      <tag>Python</tag>
      
      <tag>PyQt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>include 原理与多文件编程</title>
    <link href="/2023/03/16/include-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/03/16/include-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="头文件是怎样“包含”进来的的？"><a href="#头文件是怎样“包含”进来的的？" class="headerlink" title="头文件是怎样“包含”进来的的？"></a>头文件是怎样“包含”进来的的？</h1><p>在刚刚接触 C 语言时，同学们运行的第一个程序总是输出一个 <code>Hello world!</code>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也许你会知道，第一行叫“头文件”，但你知道这个头文件是如何被 <strong>包含</strong> 进来的吗，以及，我们为什么需要这么多头文件？</p><hr><p>在 C 语言中，以 <code>#</code> 开头的代码我们称为 <strong>预编译指令</strong>，是由 <strong>编译器</strong> 在正式编译 <strong>前</strong> 进行处理的。其中，<code>#include</code> 为包含指令，有两种写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;header-file&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;header-file&quot;</span></span><br></code></pre></td></tr></table></figure><p>以尖括号形式呈现的头文件仅适用于库文件中的头文件（大多数情况下，也许你可以通俗地理解为编译器提供的，或者是自带的头文件）。而以双引号形式呈现的头文件则 <strong>优先</strong> 在你写的源代码目录中寻找，找不到的话再去库文件中寻找<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这意味着你可以自己写一个 stdio.h，然后以双引号形式包含进去，这样就起到了“瞒天过海”的目的，但是这样子搞，未免太叛逆了吧。">[1]</span></a></sup>。一般标准库头文件用尖括号，自己写的头文件用双引号，加以区分。</p><hr><p>编译器找到了头文件，那么是如何包含进去的呢？其实很简单，<code>Ctrl+C / Ctrl+V</code>。开个玩笑啦，当然真实情况也大体如此。来看一个“叛逆”的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> num =<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;digit.h&quot;</span></span><br>        ;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&quot;digit.h&quot;</code> 是自己写的一个头文件，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure><p>这个程序当然是可以正常编译运行的，数字 <code>1024</code> 也可以被打印出来<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="这个例子还说明了，头文件未必需要始终处于代码的开头部分，甚至在函数体内都可以，当然实际情况下几乎不会这样用。">[2]</span></a></sup>。当然，需要注意的是，这个例子仅仅是个例子，真实编程中这样写是很不好的；同时，预编译指令需要 “独占一行”，也即不可以接在其他代码后面。</p><hr><p>那真实情况都是直接复制粘贴吗？其实不是。更准确地说，编译器是在 “递归” 地复制粘贴，如果头文件中还包含了其他的头文件，那么编译器会将这里面的内容全部复制过去，直到所有的 <code>#include</code> 都被干掉。</p><h1 id="头文件的作用是什么？"><a href="#头文件的作用是什么？" class="headerlink" title="头文件的作用是什么？"></a>头文件的作用是什么？</h1><p>如果你学到了“函数”这一章节，你可能会知道一种将函数的“<strong>声明</strong>”与“<strong>实现</strong>”分离的写法，你可以将函数的声明放在代码的开头，将实现放在后面。当然，更加“工程”一点的做法是，将声明放在 <code>.h</code> 头文件中，将实现放在 <code>.c</code> 源代码文件中。这种也被称为 <strong>模块化</strong> 编程，一个配对的 <code>.h</code> 与 <code>.c</code> 文件组成一个模块。</p><p>以 Dev-CPP 为例，为了实践上述想法，我们需要建立一个 “项目<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="“Project”，亦翻译为“工程”。其他 IDE 同理。">[3]</span></a></sup>”，并选择 “C 语言”、“控制台程序”。可以看到，IDE 为我们创建了一个 main.c 文件。</p><p><img src="/img/dev-new-proj.jpg" alt="Dev 中新建项目"></p><p>接着，我们 <strong>在项目中</strong> 新建两个文件：utils.h 与 utils.c，如下图所示：</p><p><img src="/img/dev-add-file.png" alt="向项目中新建文件"></p><p>并写入如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* utils.h */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> size)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* utils.c */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        res += arr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们在 main.h 中包含这个头文件，并且调用这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum(arr, <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上，编译器在编译这个项目的时候，首先会将将 utils.h 的内容“粘贴”到 main.c 的第 2 行（当然还有 stdio.h 的内容），然后进入“编译”环节，“编译”的对象仅仅是两个 .c 文件，并同时生成两个 .o 文件，也叫 <strong>目标文件</strong><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="目标代码是指源代码经过编译程序产生的，能被 CPU 直接识别并执行的二进制代码。">[4]</span></a></sup>。但这个时候，main.o 中并没有 <code>sum</code> 这个函数的“执行流程”，因为这个函数是在 utils.c 中实现的，自然会在 utils.o 这个目标文件中。所以编译器还有下一个任务，就是“链接”，将两个目标文件链接起来，让 main.o 里的 <code>sum</code> 函数能够找到正确的归宿。最终生成了一个可以正确执行的 main.exe 程序。</p><p>在整个过程中，头文件起到的作用仅仅是告知编译器 <strong>函数的原型</strong>，包括参数类型、数量，返回值类型等等，因为编译器时时刻刻总是只能处理，具体的函数实现是置于 .c 文件中的。</p><blockquote><p>注意，通常对于一个配对的源代码文件与头文件，需要在源代码文件中包含该头文件，以便于编译器更好地检查冲突。</p></blockquote><h1 id="包含头文件的正确方法"><a href="#包含头文件的正确方法" class="headerlink" title="包含头文件的正确方法"></a>包含头文件的正确方法</h1><h2 id="避免重复定义"><a href="#避免重复定义" class="headerlink" title="避免重复定义"></a>避免重复定义</h2><p>显然，当我们的程序复杂起来的时候，头文件、源代码文件的数量肯定也会多起来，其包含关系可能也会变得异常复杂，这个时候，就会出现“<strong>重复定义</strong>”的风险。接着刚才的例子，假设我们有这样的一个包含关系：</p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile&gt;&lt;diagram id=\&quot;il3yRFXszgI8L7HcCFZa\&quot; name=\&quot;Page-1\&quot;&gt;&lt;mxGraphModel dx=\&quot;566\&quot; dy=\&quot;587\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;1169\&quot; pageHeight=\&quot;827\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;&lt;root&gt;&lt;mxCell id=\&quot;0\&quot;/&gt;&lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot;/&gt;&lt;mxCell id=\&quot;18\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;fontSize=15;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;90\&quot; y=\&quot;60\&quot; width=\&quot;400\&quot; height=\&quot;290\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;7\&quot; style=\&quot;edgeStyle=none;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;fontFamily=Lucida Console;fontSize=15;\&quot; parent=\&quot;1\&quot; source=\&quot;2\&quot; target=\&quot;4\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;9\&quot; style=\&quot;edgeStyle=none;html=1;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;fontFamily=Lucida Console;fontSize=15;\&quot; parent=\&quot;1\&quot; source=\&quot;2\&quot; target=\&quot;6\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;2\&quot; value=\&quot;main.c\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;fontSize=15;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;230\&quot; y=\&quot;270\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;16\&quot; style=\&quot;edgeStyle=none;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;3\&quot; target=\&quot;4\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;3\&quot; value=\&quot;utils.c\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;fontSize=15;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;110\&quot; y=\&quot;80\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;4\&quot; value=\&quot;utils.h\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;fontSize=15;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;110\&quot; y=\&quot;160\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;17\&quot; style=\&quot;edgeStyle=none;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; edge=\&quot;1\&quot; parent=\&quot;1\&quot; source=\&quot;5\&quot; target=\&quot;6\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;5\&quot; value=\&quot;array.c\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;fontSize=15;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;350\&quot; y=\&quot;80\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;13\&quot; style=\&quot;edgeStyle=none;html=1;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;fontFamily=Lucida Console;fontSize=15;\&quot; parent=\&quot;1\&quot; source=\&quot;6\&quot; target=\&quot;4\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;6\&quot; value=\&quot;array.h\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;fontSize=15;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;350\&quot; y=\&quot;160\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;/root&gt;&lt;/mxGraphModel&gt;&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script><p>main.c 中包含了 array.h 数组模块与 utils.h 工具模块，而在 array.h 中又包含了 utils.h 工具模块，考虑到编译器的“复制粘贴”操作，utils.h 的内容在 main.c 中出现了两次。如果很不幸，utils.h 中定义了结构体，这样会导致这样的编译错误：</p><p><img src="/img/dev-redef.png" alt="重复定义的报错"></p><p>但头文件的重复包含似乎是不可避免的，因为这样符合项目的逻辑。于是我们想要一种方法，让同一个头文件只“起效”一次，可以这样操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* utils.h */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UTILS_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UTILS_H__</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> size)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point_t</span> &#123;</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;; <br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这里面有几个预编译指令，<code>#ifndef</code>，全称为 if not defined，它与 <code>endif</code> 配对，这样子一看，就很好理解啦。对于宏的命名方法，要做到不同文件不重名，并且符合标识符的命名规则。</p><blockquote><p>此外，部分编译器还可以通过在头文件开头加上 <code>#pragma once</code> 来达到类似的效果，但这并不属于 C 标准的内容。</p></blockquote><h2 id="找到全局变量"><a href="#找到全局变量" class="headerlink" title="找到全局变量"></a>找到全局变量</h2><p>有时候，我们在一个 <strong>源代码文件</strong> 中定义了一些全局变量，我们想要在其他文件中 <strong>一起</strong> 使用，这个时候，可以在 <strong>头文件</strong> 中使用 <code>extern</code> 声明这个变量。如此一来，我们可以在任何包含该头文件的源代码文件中使用这个全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* utils.h */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UTILS_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UTILS_H__</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_num</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_num;  <span class="hljs-comment">// 在这里只要声明一下有就行了。数组同理，不能再初始化。 </span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* utils.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils.h&quot;</span></span><br><br><span class="hljs-type">int</span> g_num = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 在这里是可以初始化的 </span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_num</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_num); <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* main.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    show_num();<br>    g_num = <span class="hljs-number">1024</span>;  <span class="hljs-comment">// 可以修改与读取</span><br>    show_num();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.c 中包含了 utils.h，其中有这样一句 <code>extern int g_num;</code>，它告诉编译器，“我在外面有一个叫 <code>g_num</code> 的 <code>int</code> 型的变量”，这样就可以起到跨文件“共享”的目的了。</p><p>同时，上述例子中，<code>extern</code>被置于头文件中，并在 main.c 的全局作用域被使用，因此，<code>g_num</code> 在 main.c 中也具有全局作用域，如果将这一句话，放在函数中，那么它就只在这个函数中起作用了，例如下面的例子会生成一个编译错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* main.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils.h&quot;</span>  <span class="hljs-comment">// 该头文件中不含有 extern 语句</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_in_main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// [Error] &#x27;g_num&#x27; undeclared (first use in this function)</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_num);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_num;  <span class="hljs-comment">// 在这里</span><br>    show_num();<br>    g_num = <span class="hljs-number">1024</span>;<br>    show_num();<br>    show_in_main();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="外部静态变量"><a href="#外部静态变量" class="headerlink" title="外部静态变量"></a>外部静态变量</h2><p>这里的“外部”并不是 <code>extern</code> 的那个外部，而是针对函数体而言的，将一个全局变量声明为 <code>static</code>，它的作用域就被限定在了 <strong>单个文件</strong> 之中，就不可以再用 <code>extern</code> 声明了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* utils.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> g_num = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 全局的 static，对外部文件“隐身” </span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_num</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_num); <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* utils.h */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UTILS_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __UTILS_H__</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_num</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// [Error] static declaration of &#x27;g_num&#x27; follows non-static declaration</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_num;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这意味着你可以自己写一个 stdio.h，然后以双引号形式包含进去，这样就起到了“瞒天过海”的目的，但是这样子搞，未免太叛逆了吧。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>这个例子还说明了，头文件未必需要始终处于代码的开头部分，甚至在函数体内都可以，当然实际情况下几乎不会这样用。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>“Project”，亦翻译为“工程”。其他 IDE 同理。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>目标代码是指源代码经过编译程序产生的，能被 CPU 直接识别并执行的二进制代码。<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C 语言教程</category>
      
      <category>语法讲解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言题目：三合四</title>
    <link href="/2023/01/18/C-%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE%EF%BC%9A%E4%B8%89%E5%90%88%E5%9B%9B/"/>
    <url>/2023/01/18/C-%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE%EF%BC%9A%E4%B8%89%E5%90%88%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Musha 想找一种能够和 Yamche 进行秘密交流的方式，现将编码的方式陈述如下：</p><p>对于在 ASCII 码表中定义的可打印字符，我们取出三个，记为明文，比如 <code>DAT</code>，将这三个字符的 ASCII 码用二进制并排写开，得到 $3\times8&#x3D;24$ 位（如下图第二行），将它们均分为 $4$ 组，每组 $6$ 位，并 <strong>在高位补两个零</strong>，得到四个十进制数（如下图第三行），显然，每一个十进制数一定在 $0$ 和 $63$ 之间，现给定一个字符映射表，按照这张表，将它们映射成四个的可打印字符，组成密文 <code>f23i</code>（如下图第四行）。</p><p>这便是你今天的任务，只需要将给定的明文翻译成密文。同时，为了方便交流，Musha 已经将映射表按顺序转化成一个连续的序列：</p><p><code>&quot;+-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</code></p><img src="/img/K02_01.png"><img src="/img/K02_02.png"><h4 id="输入与输出格式"><a href="#输入与输出格式" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>不定行输入，每行三个 ASCII 码表中的可打印字符，总计不超过 10000 行</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>每一行打印 4 个字符，为转换得到的密文。</p><h5 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例 #1"></a>输入样例 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">DAT<br>dat<br>Dat<br>233<br>+-*<br>!`@<br>$$$<br></code></pre></td></tr></table></figure><h5 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例 #1"></a>输出样例 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">f23i<br>n43O<br>f43O<br>axaN<br>8MOE<br>6k-+<br>70ey<br></code></pre></td></tr></table></figure><h5 id="提示说明"><a href="#提示说明" class="headerlink" title="提示说明"></a>提示说明</h5><p><strong>Hint 1</strong>: 还记得按位与运算和位移运算吗？</p><p><strong>Hint 2</strong>: 拿捏不准运算符优先级的话，不妨多加几个括号。</p><hr><h3 id="命题背景"><a href="#命题背景" class="headerlink" title="命题背景"></a>命题背景</h3><p>这是一种叫做 <code>base64</code> 编码的简化版本（其实也没简多少），我们这里只是将可打印字符转换为可打印字符，但事实上，<code>base64</code> 编码并不拘泥于此，它可以将任何内容按照字节拆开、重组（就是题设的“三”变“四”的拆法），因此，使用这种编码，可以将一张图片，转换成可打印的字符，直接嵌入网页的 <code>HTML</code> 文件。</p><h3 id="题目分析（思路一）"><a href="#题目分析（思路一）" class="headerlink" title="题目分析（思路一）"></a>题目分析（思路一）</h3><p>根据题意，我们只需要依次将四个数字取出来即可，具体而言，如果将原文存在 <code>raw</code> 中，密文的<strong>索引</strong>存在 <code>res</code> 中，有如下转换关系：</p><!--本来想着找个图床，一拍脑袋，为啥不用 base64 呢 (p≧w≦q)--><!--但是它太丑了，还是找个图床吧 ╥﹏╥...--><!--那为啥还硬要用 img 标签呢，因为我把 css 瞎改，图片也会往首行缩进 (((φ(◎ロ◎;)φ)))--><img src="/img/K02_03.png"><p><code>res[0]</code> 的低 6 位来源于 <code>raw[0]</code> 的高 6 位，只需要将 <code>raw[0]</code> 右移 2 位即可<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="注意：对于**有符号数**的右移应该特别注意，当**符号位**为 `1` 时，右移会在高位补`1`，但是，因为 ASCII 表中的字符都是正数，所以不用考虑这个问题。">[1]</span></a></sup>，有 <code>res[0] = raw[0] &gt;&gt; 2;</code>。</p><p><code>res[1]</code> 的低 4 位来源于 <code>raw[1]</code> 的高 4 位，需要先将它右移 4 位；第 5~6 位（从 1 开始）则是 <code>raw[0]</code> 的低 2 位，但是直接左移是不够的，我们还需要<strong>将高位清零</strong>，可以先让它和二进制数 <code>0b00000011</code><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="`0b` 表示二进制数的前缀，这样可以方便展示。但是请注意，C语言并**不支持**这样的写法，可以将它转化为十六进制数 `0x03` 使用。">[2]</span></a></sup> 按位与，只保留最低的两位，再位移，最后将两部分用加法或者按位或连接起来，有 <code>res[1] = ((raw[0] &amp; 0x03) &lt;&lt; 4) | (raw[1] &gt;&gt; 4);</code><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里的几个括号比较重要，因为位移运算的优先级要高于按位与。">[3]</span></a></sup>。</p><p><code>res[2]</code> 的第 3~6 位是 <code>raw[1]</code> 的低 4 位，同样需要先对 <code>0b00001111</code> 按位与，保留低 4 位，再左移到高位，而它的低 2 位则是 <code>raw[2]</code> 的高 2 位，直接右移即可，有 <code>res[2] = ((raw[1] &amp; 0x0f) &lt;&lt; 2) | (raw[2] &gt;&gt; 6);</code>。</p><p><code>res[3]</code> 则是 <code>raw[2]</code> 的低 6 位，直接使用 <code>0b00111111</code> 进行高位清零即可，有 <code>res[3] = raw[2] &amp; 0x3f;</code>。</p><h4 id="参考代码（思路一）"><a href="#参考代码（思路一）" class="headerlink" title="参考代码（思路一）"></a>参考代码（思路一）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// C 语言的双引号支持这种写法，这两个双引号中的内容会被直接连起来</span><br><span class="hljs-comment">// 写在一行里面当然没有问题，这不是导出 PDF 不好看嘛 (*^_^*)</span><br><span class="hljs-comment">// 使用转义字符也可以折行，但是要小心不要引入空格，不再赘述</span><br><span class="hljs-comment">// 使用 const 限定，可以防止误篡改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *table = <span class="hljs-string">&quot;+-0123456789abcdefghijklmnopqrstuvwxyz&quot;</span><br>                    <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">char</span> raw[<span class="hljs-number">4</span>], str[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, raw)) &#123;<br>        str[<span class="hljs-number">0</span>] = table[raw[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">2</span>];<br>        str[<span class="hljs-number">1</span>] = table[((raw[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x03</span>) &lt;&lt; <span class="hljs-number">4</span>) | (raw[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">4</span>)];<br>        str[<span class="hljs-number">2</span>] = table[((raw[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x0f</span>) &lt;&lt; <span class="hljs-number">2</span>) | (raw[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">6</span>)];<br>        str[<span class="hljs-number">3</span>] = table[raw[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x3f</span>];<br>        str[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>，如果你想写一个函数，请不要这样做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">get_result</span><span class="hljs-params">(<span class="hljs-type">char</span> raw[])</span> &#123;<br>    <span class="hljs-comment">// Wrong !!!</span><br>    <span class="hljs-type">char</span> str[<span class="hljs-number">5</span>];<br>    str[<span class="hljs-number">0</span>] = table[raw[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">2</span>];<br>    str[<span class="hljs-number">1</span>] = table[((raw[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x03</span>) &lt;&lt; <span class="hljs-number">4</span>) | (raw[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">4</span>)];<br>    str[<span class="hljs-number">2</span>] = table[((raw[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x0f</span>) &lt;&lt; <span class="hljs-number">2</span>) | (raw[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">6</span>)];<br>    str[<span class="hljs-number">3</span>] = table[raw[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x3f</span>];<br>    str[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure><p>在离开了函数体之后，<code>str</code> 会被释放掉，也就是说，这个函数返回了一个无效的指针，使用它会 <strong>REG</strong>。正确的做法是返回使用 <code>malloc</code> 分配的内存，或者使用全局变量，或者将 <code>str</code> 也作为参数传进去。</p><h3 id="题目分析（思路二）"><a href="#题目分析（思路二）" class="headerlink" title="题目分析（思路二）"></a>题目分析（思路二）</h3><p>咱就是说，免去这么多弯弯绕绕的东西，就把那三个数按位拼起来，形成一个大的数字，还是以 <code>DAT</code> 为例，拼出来的数，在二进制下就是 <code>010001000100000101010100</code>，一共 24 位，<code>int</code> 也放得下。具体而言，有 <code>int num = (raw[0] &lt;&lt; 16) + (raw[1] &lt;&lt; 8) + raw[2];</code>。</p><p>下一步，便是分别取出所要的下标，先取最后一个，直接对 <code>(0000 ... 0000 0011 1111) = 63</code> 进行按位与，这样就取出了 <code>res[3]</code>，然后将这个大数字<strong>右移 6 位</strong>，将需要的数字放到最后面，再次进行按位与，得到 <code>res[2]</code>，以此类推，即可。</p><h4 id="参考代码（思路二）"><a href="#参考代码（思路二）" class="headerlink" title="参考代码（思路二）"></a>参考代码（思路二）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 这也是一种可行的折行方案</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *table = <span class="hljs-string">&quot;+-0123456789abcdefghijklmnopqrstuvwxyz\</span><br><span class="hljs-string">ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> raw[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">int</span>  res[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, raw)) &#123;<br>        <span class="hljs-type">int</span> num = (raw[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">16</span>) + (raw[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) + raw[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            res[i] = num &amp; <span class="hljs-number">0x3f</span>; <span class="hljs-comment">// 0x3f -&gt; (0011 1111) -&gt; 63</span><br>            num &gt;&gt;= <span class="hljs-number">6</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; ++i) &#123;<br>            <span class="hljs-built_in">putchar</span>(table[res[i]]);<br>        &#125;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思路一的另一种想法"><a href="#思路一的另一种想法" class="headerlink" title="思路一的另一种想法"></a>思路一的另一种想法</h3><p>取出一个数的最后几位是不是一定要用位运算呢？如果想取出一个数二进制下的最后一位，我们可以让它和 1 进行按位与，也可以让它对 2 取模。同样的，思路一中，<code>raw[0] &amp; 0x03</code> 是想取出 <code>raw[0]</code> 的后两位，直接 <code>raw[0] % 4</code> 是不是也可以？虽然这样做有点“舍近求远”，但仍不失为一个可以思考的想法。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>注意：对于<strong>有符号数</strong>的右移应该特别注意，当<strong>符号位</strong>为 <code>1</code> 时，右移会在高位补<code>1</code>，但是，因为 ASCII 表中的字符都是正数，所以不用考虑这个问题。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><code>0b</code> 表示二进制数的前缀，这样可以方便展示。但是请注意，C语言并<strong>不支持</strong>这样的写法，可以将它转化为十六进制数 <code>0x03</code> 使用。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>这里的几个括号比较重要，因为位移运算的优先级要高于按位与。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C 语言教程</category>
      
      <category>习题解答</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 语言题目：绝妙的表格</title>
    <link href="/2023/01/18/C-%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE%EF%BC%9A%E7%BB%9D%E5%A6%99%E7%9A%84%E8%A1%A8%E6%A0%BC/"/>
    <url>/2023/01/18/C-%E8%AF%AD%E8%A8%80%E9%A2%98%E7%9B%AE%EF%BC%9A%E7%BB%9D%E5%A6%99%E7%9A%84%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>众所周知，在 Excel 表格中，用大写英文字母来表示列数。比如， <code>A</code> 表示第1列，<code>Z</code> 表示第26列，而 <code>AA</code> 表示第27列，<code>AB</code> 表示第28列。</p><p>但是，我们的 Musha 她桀骜不驯，她决定删去一些她不喜欢的字母组合，比如 <code>WA</code> <code>TLE</code> 啥的。具体而言，假设只删去 <code>B</code>，那么第2列所对应的就是 <code>C</code>；假设只删去 <code>AA</code> <code>AB</code>，那么第27列所对应的就是 <code>AC</code>。</p><p>现在，给你一个列数，要求打印出它的字母表示。</p><h4 id="输入与输出格式"><a href="#输入与输出格式" class="headerlink" title="输入与输出格式"></a>输入与输出格式</h4><h5 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h5><p>第$1$行两个 <code>int</code> 以内的整数 <code>col</code> 与 <code>n</code>，<code>col</code> 表示所求目标列数（不会为$0$），<code>n</code> 表示待删去字母组合的个数。</p><p>第$2$至$n+1$行，每行一个字符串，表示需要删去的字母组合。所有给出的字符串不重复，并且按照列数的递增排列。</p><h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>一行一个由大写字母组成的字符串，表示在删去相关组合的前提下，列数 <code>col</code> 所代表的字母表示。</p><h5 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例 #1"></a>输入样例 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">2147483647 0<br></code></pre></td></tr></table></figure><h5 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例 #1"></a>输出样例 #1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">FXSHRXW<br></code></pre></td></tr></table></figure><h5 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例 #2"></a>输入样例 #2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">27 2<br>AA<br>AB<br></code></pre></td></tr></table></figure><h5 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例 #2"></a>输出样例 #2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">AC<br></code></pre></td></tr></table></figure><h5 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例 #3"></a>输入样例 #3</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">29 3<br>WA<br>REG<br>TLE<br></code></pre></td></tr></table></figure><h5 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例 #3"></a>输出样例 #3</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">AC<br></code></pre></td></tr></table></figure><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>对于 $30%$ 的数据，$\text{n}&#x3D;0$</p><p>对于另外 $30%$ 的数据，$\text{n}&#x3D;1$</p><p>对于 $100%$ 的数据，$1 \leqslant \text{col} \leqslant 2147483647$，$0 \leqslant \text{n} \leqslant 100000$ 并保证所输出的字母表示的真实值不超过 <code>int</code> 范围</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>提供两个<strong>方向不同</strong>的思路，希望可以有所启发：</p><p>【思路一】与通常情况的进制转换不同，在题设环境中，<strong>每一位</strong>所代表的数字的取值都为 1~26，那我们为什么不把它变成 0~25 的范围呢，这样就可以愉快地取模、做除法了。或者是，哪怕只变一部分呢，比如，，，比如最后一位？</p><p>【思路二】或者我们干脆就把它按照常规的二十六进制写出来，那遇到 0 怎么办？是不是可以，，，可以向人家借呢？</p><hr><h3 id="命题背景"><a href="#命题背景" class="headerlink" title="命题背景"></a>命题背景</h3><p>原题链接：<a href="https://leetcode.cn/problems/excel-sheet-column-title/">168. Excel表列名称 - 力扣</a></p><p>在原题的基础上增加了 “删去某些字母组合” 的要求。</p><p>拓展题目：<a href="https://www.luogu.com.cn/problem/CF1B">洛谷 CF1B Spreadsheets</a></p><h3 id="题目分析（思路一）"><a href="#题目分析（思路一）" class="headerlink" title="题目分析（思路一）"></a>题目分析（思路一）</h3><p>首先是考虑如何让将数字转换为字母，我们先假设 $703&#x3D;x&#x3D;\text{AAA}$，其中，每一个 $\text{A}$ 均代表<strong>该位</strong>的 $1$，但如果我们重新规定一下，<strong>最后一位</strong>的字母所代表的数字的取值范围是 0~25，而不是前面的 1~26，也即 $\text{AAA}’&#x3D;x-1$，这样，$(x-1)%26$ 的值，就是 $\text{A}’$ 的值，$0$，而 $(x-1)&#x2F;26$ 则是 $27&#x3D;\text{AA}$。</p><p>利用这个思路，我们可以写出一个数字转字母组合的函数，见参考代码中 <code>void converToString(int)</code> 的实现。</p><p>其次考虑将字母组合转化成数字，这个不难，从最低位开始，依次为 $26^0$，$26^1$，$\cdots$，见参考代码中 <code>int converToNumber(const char[])</code> 的实现。</p><p>最后一个点是如何处理哪些被删去的字母组合，因为它们是<strong>有序</strong>的，我们可以一个一个读取，将它们转换成数字，与我们的目标进行比较。如果待删去的数字<strong>小于或者等于</strong>目标数字，就将目标数字向后挪一位；一旦待删去的数字比目标数字大，那么后面也就没有必要再去读取了，可以直接<strong>提前结束</strong>这个过程。</p><h4 id="参考代码（思路一）"><a href="#参考代码（思路一）" class="headerlink" title="参考代码（思路一）"></a>参考代码（思路一）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">convertToString</span><span class="hljs-params">(<span class="hljs-type">int</span> col)</span> &#123;<br>    <span class="hljs-type">char</span> res[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span>  pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (col) &#123;<br>        res[pos++] = (col - <span class="hljs-number">1</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>;<br>        col = (col - <span class="hljs-number">1</span>) / <span class="hljs-number">26</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">putchar</span>(res[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 const 限定，防止误修改</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertToNumber</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> s[])</span> &#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, ratio = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        res += ratio * (s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span>);<br>        ratio *= <span class="hljs-number">26</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>  col, n;<br>    <span class="hljs-type">int</span>  discard_num;<br>    <span class="hljs-type">char</span> discard_alpha[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;col, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, discard_alpha);<br>        discard_num = convertToNumber(discard_alpha);<br>        <span class="hljs-keyword">if</span> (discard_num &lt;= col) &#123;<br>            ++col;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    convertToString(col);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="题目分析（思路二）"><a href="#题目分析（思路二）" class="headerlink" title="题目分析（思路二）"></a>题目分析（思路二）</h3><p>只考虑数字转换成字母的方法，思考一下通常的进制转换的做法，比如对 $702$ 进行连续取模与除法，可以得到：$702&#x3D;1\times26^2+1\times26^1+0\times26^0$，也就是如下代码会得到的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">i = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span> (n) &#123;<br>    res[++i] = n % <span class="hljs-number">26</span>;<br>    n /= <span class="hljs-number">26</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们的下一步是考虑，如何将这些不和谐的 $0$ 给干掉。如果大家联想到了竖式减法的 <strong>“借一当十”</strong>，那么这里也可以类似的处理。比如，我们可以把第二位的 $1\times26^1$ 拿一个 $26$ 过来，放到第一位（后面有图说明），写成 $702&#x3D;1\times26^2+0\times26^1+26\times26^0$，再考虑第二位，又有一个 $0$，那么就可以问第三位去要，写成 $702&#x3D;0\times26^2+26\times26^1+26\times26^0$，这样我们要的结果就是 $(26,26)\Rightarrow ZZ$ 了。</p><p>这里还要考虑一个问题：如果前面有好几个连在一起的 $0$，那我去和谁借？可以使用 <code>while</code> 一直向前找，但其实不需要这样麻烦，直接借呗，借成 $-1$ 也无所谓，循环到这个 $-1$ 的时候再向继续前面借就可以了，于是，需要向前借的条件是某一位<strong>小于或等于 0</strong>。</p><img src="/img/K01_01.png"><h4 id="参考代码（思路二）"><a href="#参考代码（思路二）" class="headerlink" title="参考代码（思路二）"></a>参考代码（思路二）</h4><p>其他部分与“思路一”保持一致，这里需要弄清楚<strong>遍历的顺序</strong>，数组里面，哪一位是“前”，哪一位是“后”，输出的时候要不要倒过来，等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">convertToString</span><span class="hljs-params">(<span class="hljs-type">int</span> col)</span> &#123;<br>    <span class="hljs-type">int</span> res[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (col) &#123;<br>        res[pos++] = col % <span class="hljs-number">26</span>;<br>        col /= <span class="hljs-number">26</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pos - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (res[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>            res[i] += <span class="hljs-number">26</span>;<br>            --res[i + <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最高位特判一下，防止减成 0</span><br>    <span class="hljs-keyword">if</span> (res[pos - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-built_in">putchar</span>(res[pos - <span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">putchar</span>(res[i] + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C 语言教程</category>
      
      <category>习题解答</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逗号表达式的介绍与简单运用</title>
    <link href="/2022/09/09/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8/"/>
    <url>/2022/09/09/%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>当遇到循环输入正整数，直到输入 0 停止时，可以这样处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br><span class="hljs-keyword">while</span> (num) &#123;<br>    <span class="hljs-comment">// deal with num</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    <span class="hljs-keyword">if</span> (!num) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// deal with num</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前者的 <code>scanf</code> 出现重复，后者的 <code>while</code> + <code>if</code> 则显得鸡肋，都不够优雅。我们不妨先来分析一下：</p><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile&gt;&lt;diagram id=\&quot;RUiPgumOw6pdPrz8ipsX\&quot; name=\&quot;第 1 页\&quot;&gt;&lt;mxGraphModel dx=\&quot;970\&quot; dy=\&quot;587\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;827\&quot; pageHeight=\&quot;1169\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;&lt;root&gt;&lt;mxCell id=\&quot;0\&quot;/&gt;&lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot;/&gt;&lt;mxCell id=\&quot;15\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;&lt;mxGeometry width=\&quot;350\&quot; height=\&quot;450\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;14\&quot; value=\&quot;\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;fontSize=11;fillColor=none;dashed=1;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;60\&quot; y=\&quot;30\&quot; width=\&quot;230\&quot; height=\&quot;210\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;4\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=none;html=1;\&quot; parent=\&quot;1\&quot; source=\&quot;2\&quot; target=\&quot;3\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;2\&quot; value=\&quot;scanf(&amp;quot;%d&amp;quot;, &amp;amp;amp;num);\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;90\&quot; y=\&quot;50\&quot; width=\&quot;160\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;6\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=none;html=1;fontFamily=Lucida Console;fontSize=11;metaEdit=0;\&quot; parent=\&quot;1\&quot; source=\&quot;3\&quot; target=\&quot;5\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry relative=\&quot;1\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;7\&quot; value=\&quot;Yes\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontSize=11;fontFamily=Lucida Console;\&quot; parent=\&quot;6\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;&gt;&lt;mxGeometry x=\&quot;-0.4148\&quot; y=\&quot;2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;mxPoint x=\&quot;-22\&quot; y=\&quot;8\&quot; as=\&quot;offset\&quot;/&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;3\&quot; value=\&quot;num != 0\&quot; style=\&quot;rhombus;whiteSpace=wrap;html=1;rounded=0;fontFamily=Lucida Console;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;90\&quot; y=\&quot;150\&quot; width=\&quot;160\&quot; height=\&quot;80\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;5\&quot; value=\&quot;(deal with num)\&quot; style=\&quot;whiteSpace=wrap;html=1;fontFamily=Lucida Console;rounded=0;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;110\&quot; y=\&quot;270\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;8\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=elbowEdgeStyle;elbow=vertical;endArrow=classic;html=1;fontFamily=Lucida Console;fontSize=11;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;5\&quot; target=\&quot;2\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;mxPoint x=\&quot;360\&quot; y=\&quot;260\&quot; as=\&quot;sourcePoint\&quot;/&gt;&lt;mxPoint x=\&quot;410\&quot; y=\&quot;210\&quot; as=\&quot;targetPoint\&quot;/&gt;&lt;Array as=\&quot;points\&quot;&gt;&lt;mxPoint x=\&quot;320\&quot; y=\&quot;190\&quot;/&gt;&lt;/Array&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;9\&quot; value=\&quot;(go to end)\&quot; style=\&quot;rounded=0;whiteSpace=wrap;html=1;fontFamily=Lucida Console;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;&lt;mxGeometry x=\&quot;110\&quot; y=\&quot;370\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot;/&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;11\&quot; value=\&quot;\&quot; style=\&quot;edgeStyle=elbowEdgeStyle;elbow=vertical;endArrow=classic;html=1;fontFamily=Lucida Console;fontSize=11;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;3\&quot; target=\&quot;9\&quot; edge=\&quot;1\&quot;&gt;&lt;mxGeometry width=\&quot;50\&quot; height=\&quot;50\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;mxPoint x=\&quot;230\&quot; y=\&quot;340\&quot; as=\&quot;sourcePoint\&quot;/&gt;&lt;mxPoint x=\&quot;280\&quot; y=\&quot;290\&quot; as=\&quot;targetPoint\&quot;/&gt;&lt;Array as=\&quot;points\&quot;&gt;&lt;mxPoint x=\&quot;40\&quot; y=\&quot;370\&quot;/&gt;&lt;/Array&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;mxCell id=\&quot;12\&quot; value=\&quot;No\&quot; style=\&quot;edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontSize=11;fontFamily=Lucida Console;\&quot; parent=\&quot;11\&quot; vertex=\&quot;1\&quot; connectable=\&quot;0\&quot;&gt;&lt;mxGeometry x=\&quot;-0.8917\&quot; y=\&quot;2\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;&lt;mxPoint x=\&quot;-52\&quot; y=\&quot;58\&quot; as=\&quot;offset\&quot;/&gt;&lt;/mxGeometry&gt;&lt;/mxCell&gt;&lt;/root&gt;&lt;/mxGraphModel&gt;&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div><script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script><p>流程是这样没有问题，只是我们应该将虚线框中的内容看成一个整体，<code>scanf</code> 应该和判断在 <strong>一起</strong> 并且每次都先于判断语句执行。</p><p>于是我们想到了 <code>for</code> 语句，<code>for</code> 语句的第三部分会被执行，然后再进行判断，于是我们可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num); num != <span class="hljs-number">0</span>; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num)) &#123;<br>    <span class="hljs-comment">// deal with num</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是 <code>scanf</code> 语句还是要写两遍！ : (</p><p>究其原因，是 <code>for</code> 语句中三个小句的执行顺序导致的。</p><h3 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h3><p>其实 C 语言标准中还有一种逗号表达式，逗号 <strong>运算符</strong> 是一种优先级 <strong>最低</strong> 的运算符，具有 <strong>从左到右</strong> 的结合性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">&lt;expression <span class="hljs-number">1</span>&gt;, &lt;expression <span class="hljs-number">2</span>&gt;<br></code></pre></td></tr></table></figure><p>这种情况下，会依次执行 <code>expression 1</code> 与 <code>expression 2</code>，由 <code>expression 2</code> 的值作为整体的值。又有以下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">num1 = (++a, <span class="hljs-number">6</span>);  <span class="hljs-comment">// a 自增, num1 被赋为 6</span><br>num2 = ++a, <span class="hljs-number">6</span>;    <span class="hljs-comment">// a 自增, num2 被赋为 a 的值</span><br></code></pre></td></tr></table></figure><p>于是，我们可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num), num != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// deal with num</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，程序每次会先执行 <code>scanf(&quot;%d&quot;, &amp;num)</code>，再执行 <code>num != 0</code>，并将后者的值作为 <code>while</code> 判断的依据，这样就将我们的需求比较完美地解决了。</p><hr><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>回到第一次上机的 E 题：</p><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>小羊学姐很开兴又有新生来到校园学习啦！兴奋之下，她报名了帮助新生学弟学妹们搬书的志愿活动（大家都知道开学的新教材真的很多啊）。志愿工作当天，有好多书需要搬，书籍被分成了一堆一堆的，每个书堆分别有 $a_1$, $a_2$, $a_3$, $\cdots$, $a_n$, $\cdots$ 本书，小羊学姐每一次需要搬一个书堆（有且仅一个）的书到目的地去。由于书籍堆数太多，所以一眼看不出来一共有多少堆，小羊学姐想请你帮忙求出：对于今天的搬书工作，一共有多少本书籍？一共有多少个书堆？她平均每次搬了多少本？（本题的测试数据给得比较简单，题中直接用 <code>int</code> 定义变量就可以了）</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>一共有若干行输入，每行输入一个 <code>int</code> 型的正整数，当输入 <code>0</code> 时表明输入结束，且 <code>0</code> 不计入书籍堆数</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>一共有一行输出，三个 <code>int</code> 型的正整数，从左往右依次为：书籍总数，书堆总数，平均每次搬运的书籍个数（每两个正整数之间一个空格）</p><h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br>0<br></code></pre></td></tr></table></figure><h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>AC 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> book = <span class="hljs-number">0</span>, heap = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tmp;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;tmp), tmp) &#123;<br>        book += tmp;<br>        ++heap;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (heap)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, book, heap, book / heap);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 0 0&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>请注意，函数调用时参数列表里的逗号和定义多个变量时的逗号不属于逗号表达式，它们只是一种分隔符。同时，多个逗号表达式可以连用，依然取最后一个值。</p>]]></content>
    
    
    <categories>
      
      <category>C 语言教程</category>
      
      <category>语法讲解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 批量删除 word 中所有页眉、页脚</title>
    <link href="/2021/02/19/Python-%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4-word-%E4%B8%AD%E6%89%80%E6%9C%89%E9%A1%B5%E7%9C%89%E3%80%81%E9%A1%B5%E8%84%9A/"/>
    <url>/2021/02/19/Python-%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4-word-%E4%B8%AD%E6%89%80%E6%9C%89%E9%A1%B5%E7%9C%89%E3%80%81%E9%A1%B5%E8%84%9A/</url>
    
    <content type="html"><![CDATA[<blockquote><p>警告：此文章方法不能应对所有情况。甚至于在大多数情况是没有用的。</p></blockquote><p>之前看网上的资料，大部分都是用 <code>python-docx</code> 库来删除 word 文档的页眉、页脚：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">header.is_linked_to_previous = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>但是实际使用下来，问题不少，也不能保证所有页面（尤其是第一页）的页眉、页脚都被有效清除。<br>于是我想使用 <code>win32com</code> ，但网上的资料实在太少。经过一番探索，我得出了下面的方法：</p><p>首先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pypiwin32<br></code></pre></td></tr></table></figure><p>编写 python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> win32com <span class="hljs-keyword">import</span> client<br><br><span class="hljs-comment"># 用来进行 word 文档的打开、保存、关闭操作</span><br>word = client.DispatchEx(<span class="hljs-string">&quot;Word.Application&quot;</span>)<br><br><span class="hljs-comment"># 删除页眉、页脚的核心</span><br>wb = client.DispatchEx(<span class="hljs-string">&quot;Word.Basic&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">removeHeaderFooter</span>(<span class="hljs-params">file</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        Para: file: word文档路径，需要包括文件名、拓展名</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 打开文档，注意参数要是绝对路径，可以使用 os 库的方法进行转化</span><br>    wordDoc = word.Documents.Open(os.path.abspath(file), ReadOnly=<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-comment"># 调用 Word.Basic 来进行操作</span><br>    <span class="hljs-comment"># 注意后面没有表示函数的括号</span><br>    wb.RemoveHeader<br>    wb.RemoveFooter<br><br>    <span class="hljs-comment"># 保存文件，此外还可以为 SaveAs 函数增加 FileFormat=17 参数来保存为 pdf 文件（拓展名需要更改一下）</span><br>    wordDoc.SaveAs(os.path.abspath(file))<br><br>    <span class="hljs-comment"># 注意，一定要关闭文件，因此建议将上面内容用 try 包起来，确保文件关闭</span><br>    <span class="hljs-comment"># 如果没有正确关闭，则下次无法正常打开</span><br>    <span class="hljs-comment"># 如有意外，可以将任务管理器中的 WINWORD 进程关闭，并将文件夹内的隐藏文件 ~$... .docx 删掉（可能是隐藏的）</span><br>    wordDoc.Close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    removeHeaderFooter(<span class="hljs-string">&#x27;test.docx&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>如果需要遍历文件夹内所有 word 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 遍历文件夹</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> os.listdir(path):<br>    <span class="hljs-comment"># 判断是文件，且是 word 文件</span><br>    <span class="hljs-keyword">if</span> os.path.isfile(os.path.join(path, name)) <span class="hljs-keyword">and</span> name.split(<span class="hljs-string">&#x27;.&#x27;</span>)[-<span class="hljs-number">1</span>].lower() <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;doc&#x27;</span>, <span class="hljs-string">&#x27;docx&#x27;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>:removing header and footer...&#x27;</span>)<br>        removeHeaderFooter(os.path.join(path, name))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python 教程</category>
      
      <category>实用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Office</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
